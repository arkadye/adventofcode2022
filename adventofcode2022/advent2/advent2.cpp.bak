#include "advent2.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY2DBG 1
#ifdef NDEBUG
#define DAY2DBG 0
#else
#define DAY2DBG ENABLE_DAY2DBG
#endif

#if DAY2DBG
	#include <iostream>
#endif

namespace
{
#if DAY2DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <algorithm>
#include <sstream>
#include <string_view>

#include <coords.h>
#include <istream_line_iterator.h>
#include <parse_utils.h>
#include <to_value.h>

namespace
{
	using coords = utils::basic_coords<int64_t>;

	coords parse_line(std::string_view line)
	{
		const auto [direction, magnitude_str] = utils::split_string_at_first(line, ' ');
		const int64_t magnitude = utils::to_value<int64_t>(magnitude_str);
		if (direction[0] == 'u')
		{
			return coords{ 0,-magnitude };
		}
		else if (direction[0] == 'd')
		{
			return coords{ 0,magnitude };
		}
		else if(direction[0] == 'f')
		{
			return coords{ magnitude,0 };
		}
		AdventUnreachable();
	}

	coords get_final_location_p1(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		const coords result = std::transform_reduce(ILI{ input }, ILI{},
			coords{ 0,0 }, std::plus<coords>{}, parse_line);
		return result;
	}

	int64_t solve_p1(std::istream& input)
	{
		const coords final_position = get_final_location_p1(input);
		return final_position.x * final_position.y;
	}
}

namespace
{
	coords get_final_location_p2(std::istream& input)
	{
		int64_t aim = 0;
		coords result{ 0,0 };
		for (const std::string& line : utils::line_range{ input })
		{
			const coords parse_result = parse_line(line);
			if (parse_result.x == 0)
			{
				aim += parse_result.y;
			}
			else
			{
				const coords dir{ aim * parse_result.x,parse_result.x };
				result += dir;
			}
		}
		return result;
	}

	int64_t solve_p2(std::istream& input)
	{
		const coords result = get_final_location_p2(input);
		return result.x * result.y;
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(forward 5
down 5
forward 8
up 3
down 8
forward 2)"
		};
	}
}

ResultType day_two_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_two_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_two_p1()
{
	auto input = advent::open_puzzle_input(2);
	return solve_p1(input);
}

ResultType advent_two_p2()
{
	auto input = advent::open_puzzle_input(2);
	return solve_p2(input);
}

#undef DAY2DBG
#undef ENABLE_DAY2DBG