#include "advent13.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY13DBG 1
#ifdef NDEBUG
#define DAY13DBG 0
#else
#define DAY13DBG ENABLE_DAY13DBG
#endif

#if DAY13DBG
	#include <iostream>
#endif

namespace
{
#if DAY13DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <sstream>
#include <string>
#include <vector>
#include <numeric>
#include <algorithm>
#include <string_view>

#include <coords.h>
#include <int_range.h>
#include <to_value.h>
#include <parse_utils.h>
#include <istream_line_iterator.h>

namespace
{
	using utils::coords;

	using Image = std::vector<coords>;

	std::pair<coords, coords> get_extents(const Image& image)
	{
		constexpr int low_init = std::numeric_limits<int>::max();
		constexpr int high_init = std::numeric_limits<int>::min();
		constexpr std::pair init{ coords{low_init},coords{high_init} };
		const auto coord_minmax = [](std::pair<coords,coords> l, const coords& r)
		{
			l.first.x = std::min(l.first.x, r.x);
			l.first.y = std::min(l.first.y, r.y);
			l.second.x = std::max(l.second.x, r.x);
			l.second.y = std::max(l.second.y, r.y);
			return l;
		};

		const auto result = std::accumulate(begin(image), end(image), init, coord_minmax);
		return result;
	}

	Image clean_image(Image image)
	{
		std::ranges::sort(image);
		const auto new_end = std::unique(begin(image),end(image));
		image.erase(new_end,end(image));
		return image;
	}

	std::string print_image(Image image)
	{
		image = clean_image(std::move(image));
		const auto [bottom_left, top_right] = get_extents(image);

		utils::int_range x_range{ bottom_left.x,top_right.x + 1 };
		utils::int_range y_range{ bottom_left.y,top_right.y + 1 };

		std::ostringstream result;
		result << '\n';

		std::transform(begin(y_range), end(y_range), std::ostream_iterator<std::string>{result, "\n"},
			[&image,&x_range](int y)
		{
			std::string line;
			line.reserve(x_range.size());

			std::transform(begin(x_range), end(x_range), std::back_inserter(line),
				[&image, y](int x)
			{
				const bool should_mark = std::ranges::binary_search(image, coords{ x,y });
				return should_mark ? '#' : ' ';
			});
			return line;
		});
		
		return result.str();
	}

	enum class Axis : char { x, y };
	struct FoldInstruction
	{
		int coord = 0;
		Axis axis = Axis::x;
	};

	FoldInstruction get_fold_data(std::string_view line)
	{
		AdventCheck(utils::get_string_element(line, 0) == "fold");
		AdventCheck(utils::get_string_element(line, 1) == "along");
		const auto arg = utils::get_string_element(line, 2);
		const auto [axis_s, coord_s] = utils::split_string_at_first(arg, '=');

		FoldInstruction result;
		result.coord = utils::to_value<int>(coord_s);

		if (axis_s == "x")
		{
			result.axis = Axis::x;
		}
		else if (axis_s == "y")
		{
			result.axis = Axis::y;
		}
		else
		{
			AdventUnreachable();
		}
		return result;
	}

	int fold_1D(int val, int axis)
	{
		AdventCheck(val >= 0);
		AdventCheck(val != axis);
		if (val < axis)
		{
			return val;
		}

		const int difference = std::abs(val - axis);
		val = axis - difference;
		AdventCheck(val >= 0);
		return val;
	}

	coords fold_2D(coords pixel, FoldInstruction fold)
	{
		int& relevant_coord = [&fold,&pixel]() -> int&
		{
			switch (fold.axis)
			{
			case Axis::x:
				return pixel.x;
			case Axis::y:
				return pixel.y;
			}
			AdventUnreachable();
			return pixel.x;
		}();

		relevant_coord = fold_1D(relevant_coord, fold.coord);
		return pixel;
	}

	Image fold_image(Image image, FoldInstruction fold)
	{
		std::ranges::transform(image, begin(image),
			[&fold](const coords& c)
		{
			return fold_2D(c, fold);
		});
		return image;
	}

	Image fold(Image image, std::string_view fold_data)
	{
		return fold_image(std::move(image), get_fold_data(fold_data));
	}

	coords get_coords(std::string_view line)
	{
		const auto [x_s, y_s] = utils::split_string_at_first(line, ',');
		const int x = utils::to_value<int>(x_s);
		const int y = utils::to_value<int>(y_s);
		AdventCheck(x >= 0);
		AdventCheck(y >= 0);
		return coords{ x,y };
	}

	Image read_image(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		Image image;

		auto it = ILI{ input };
		while (true)
		{
			const std::string line = *it++;
			if (line.empty()) break;
			image.push_back(get_coords(line));
		}

		return image;
	}

	std::size_t solve_p1(std::istream& input)
	{
		Image image = read_image(input);
		std::string first_instruction;
		std::getline(input, first_instruction);
		image = fold(std::move(image), first_instruction);
		image = clean_image(std::move(image));
		return image.size();
	}
}

namespace
{
	std::string solve_p2(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		Image image = read_image(input);
		image = std::accumulate(ILI{ input }, ILI{}, std::move(image), fold);
		return print_image(image);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(6,10
0,14
9,10
0,3
10,4
4,11
6,0
6,12
4,1
0,13
10,12
3,4
3,0
8,4
1,10
2,14
8,10
9,0

fold along y=7
fold along x=5)"
		};
	}
}

ResultType day_thirteen_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_thirteen_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_thirteen_p1()
{
	auto input = advent::open_puzzle_input(13);
	return solve_p1(input);
}

ResultType advent_thirteen_p2()
{
	auto input = advent::open_puzzle_input(13);
	return solve_p2(input);
}

#undef DAY13DBG
#undef ENABLE_DAY13DBG