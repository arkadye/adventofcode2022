#include "advent5.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY5DBG 1
#ifdef NDEBUG
#define DAY5DBG 0
#else
#define DAY5DBG ENABLE_DAY5DBG
#endif

#if DAY5DBG
	#include <iostream>
#endif

namespace
{
#if DAY5DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <coords.h>
#include <parse_utils.h>
#include <to_value.h>
#include <istream_line_iterator.h>

#include <map>

namespace
{
	using Point = utils::coords;

	enum class Direction
	{
		vertical,
		horizontal,
		upward,
		downward
	};
	
	struct Line
	{
		Point start, end;
		Line() = default;
		Line(Point a, Point b) : start{ a }, end{ b }{}
		Line(const Line&) = default;
		int x_min() const {	return std::min(start.x, end.x); }
		int y_min() const {	return std::min(start.y, end.y); }
		int x_max() const { return std::max(start.x, end.x); }
		int y_max() const { return std::max(start.y, end.y); }
		Direction get_direction() const
		{
			const utils::coords offset = end - start;
			if (offset.x == 0) return Direction::vertical;
			if (offset.y == 0) return Direction::horizontal;
			if (offset.x == offset.y) return Direction::upward;
			AdventCheckMsg(offset.x == -offset.y, "Line does not go in a recognised direction");
			return Direction::downward;
		}
		bool is_straight() const
		{
			const Direction dir = get_direction();
			return dir == Direction::vertical || dir == Direction::horizontal;
		}
	};

	// Reads "x,y" formatted string
	Point get_point(std::string_view input)
	{
		using utils::to_value;
		const auto [x, y] = utils::split_string_at_first(input, ',');
		return Point{ to_value<int>(x),to_value<int>(y) };
	}

	Line get_line(std::string_view input)
	{
		const auto [a, b] = utils::get_string_elements(input, 0, 2);
		return Line{ get_point(a),get_point(b) };
	}

	using CloudMap = std::map<Point, int>;

	CloudMap add_cloud_from_line_horizontal(CloudMap clouds, const Line& line)
	{
		AdventCheck(line.get_direction() == Direction::horizontal);
		const int y = line.y_min();
		for (int x = line.x_min(); x <= line.x_max(); ++x)
		{
			const Point p{ x,y };
			++clouds[p];
		}
		return clouds;
	}

	CloudMap add_cloud_from_line_vertical(CloudMap clouds, const Line& line)
	{
		AdventCheck(line.get_direction() == Direction::vertical);
		const int x = line.x_min();
		for (int y = line.y_min(); y <= line.y_max(); ++y)
		{
			const Point p{ x,y };
			++clouds[p];
		}
		return clouds;
	}

	CloudMap add_cloud_from_line_upward(CloudMap clouds, const Line& line)
	{
		AdventCheck(line.get_direction() == Direction::upward);
		for (int x=line.x_min(), y = line.y_min();x<=line.x_max() && y <= line.y_max();++x, ++y)
		{
			const Point p{ x,y };
			++clouds[p];
		}
		return clouds;
	}

	CloudMap add_cloud_from_line_downward(CloudMap clouds, const Line& line)
	{
		AdventCheck(line.get_direction() == Direction::downward);
		for (int x = line.x_min(), y = line.y_max(); x <= line.x_max() && y >= line.y_min(); ++x, --y)
		{
			const Point p{ x,y };
			++clouds[p];
		}
		return clouds;
	}

	CloudMap add_cloud_from_line(CloudMap clouds, const Line& line, bool allow_diagonals)
	{
		if (!allow_diagonals && !line.is_straight()) return clouds;
		const Direction dir = line.get_direction();
		switch (dir)
		{
		case Direction::horizontal:
			return add_cloud_from_line_horizontal(std::move(clouds), line);
		case Direction::vertical:
			return add_cloud_from_line_vertical(std::move(clouds), line);
		case Direction::upward:
			return add_cloud_from_line_upward(std::move(clouds), line);
		case Direction::downward:
			return add_cloud_from_line_downward(std::move(clouds), line);
		}
		AdventUnreachable();
		return clouds;
	}

	CloudMap add_cloud_from_str(CloudMap clouds, std::string_view line, bool allow_diagonals)
	{
		const Line l = get_line(line);
		return add_cloud_from_line(std::move(clouds), l, allow_diagonals);
	}

	CloudMap get_cloud_map(std::istream& input, bool allow_diagonals)
	{
		using ILI = utils::istream_line_iterator;
		return std::accumulate(ILI{ input }, ILI{}, CloudMap{},
			[allow_diagonals](CloudMap clouds, std::string_view sv)
		{
			return add_cloud_from_str(std::move(clouds), sv, allow_diagonals);
		});
	}

	int solve_generic(std::istream& input, bool allow_diagonals)
	{
		const CloudMap clouds = get_cloud_map(input, allow_diagonals);
		return std::count_if(begin(clouds), end(clouds),
			[](const CloudMap::value_type& val)
		{
			return val.second > 1;
		});
	}

	int solve_p1(std::istream& input)
	{
		return solve_generic(input, false);
	}

	int solve_p2(std::istream& input)
	{
		return solve_generic(input, true);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2)"
		};
	}
}

ResultType day_five_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_five_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_five_p1()
{
	auto input = advent::open_puzzle_input(5);
	return solve_p1(input);
}

ResultType advent_five_p2()
{
	auto input = advent::open_puzzle_input(5);
	return solve_p2(input);
}

#undef DAY5DBG
#undef ENABLE_DAY5DBG