#include "advent10.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY10DBG 1
#ifdef NDEBUG
#define DAY10DBG 0
#else
#define DAY10DBG ENABLE_DAY10DBG
#endif

#if DAY10DBG
	#include <iostream>
#endif

namespace
{
#if DAY10DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <string_view>
#include <algorithm>
#include <numeric>
#include <variant>

#include <istream_line_iterator.h>
#include <sorted_vector.h>
#include <transform_if.h>

namespace
{
	using Bracket = char;
	using BracketStack = std::string;

	struct BracketInfo
	{
		Bracket open = 0;
		Bracket close = 0;
		int64_t corrupt_score = 0;
		int64_t incomplete_score = 0;
	};

	constexpr std::array<BracketInfo, 4> BRACKETS = {
		BracketInfo{'(',')',3,1},
		BracketInfo{'[',']',57,2},
		BracketInfo{'{','}',1197,3},
		BracketInfo{'<','>',25137,4}
	};

	enum class BracketType : char
	{
		open, close, error
	};

	struct BracketResult
	{
		BracketInfo info;
		BracketType type;
	};

	BracketResult get_bracket_info(Bracket b)
	{
		const auto open_it = std::ranges::find_if(BRACKETS, [b](BracketInfo bi)
		{
			return bi.open == b;
		});
		if (open_it != end(BRACKETS))
		{
			return BracketResult{ *open_it,BracketType::open };
		}

		const auto close_it = std::ranges::find_if(BRACKETS, [b](BracketInfo bi)
		{
			return bi.close == b;
		});
		if (close_it != end(BRACKETS))
		{
			return BracketResult{ *close_it,BracketType::close };
		}

		return BracketResult{ BracketInfo{0,0,0}, BracketType::error };
	}

	std::variant<BracketInfo,BracketStack> parse_line(std::string_view line)
	{
		BracketStack bracket_stack;

		for (Bracket b : line)
		{
			const auto [info, type] = get_bracket_info(b);
			switch (type)
			{
			case BracketType::open:
				bracket_stack.push_back(b);
				break;
			case BracketType::close:
				if (!bracket_stack.empty() && bracket_stack.back() == info.open)
				{
					bracket_stack.pop_back();
				}
				else
				{
					return info;
				}
				break;
			case BracketType::error:
				AdventUnreachable();
			}
		}
		return bracket_stack;
	}

	// Legal / complete lines score 0
	int64_t score_corrupted_line(std::string_view line)
	{
		const auto info = parse_line(line);
		if (std::holds_alternative<BracketInfo>(info))
		{
			const BracketInfo& result = std::get<BracketInfo>(info);
			return result.corrupt_score;
		}
		return 0;
	}

	int64_t score_unclosed_brackets(const BracketStack& stack, int64_t mul)
	{
		const auto acc = [mul](int64_t total, Bracket next)
		{
			const auto [info, type] = get_bracket_info(next);
			AdventCheck(type == BracketType::open);
			return total * mul + info.incomplete_score;
		};
		const int64_t result = std::accumulate(rbegin(stack), rend(stack), int64_t{ 0 }, acc);
		return result;
	}

	// Legal / corrupt lines score 0
	template <int64_t SCORE_MUL>
	int64_t score_incomplete_line(std::string_view line)
	{
		auto info = parse_line(line);
		if (std::holds_alternative<BracketStack>(info))
		{
			BracketStack unclosed = std::move(std::get<BracketStack>(info));
			const int64_t result = score_unclosed_brackets(unclosed,SCORE_MUL);
			return result;
		}
		return 0;
	}

	int64_t solve_p1(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		return std::transform_reduce(ILI{ input }, ILI{}, int64_t{ 0 }, std::plus<int64_t>{}, score_corrupted_line);
	}
}

namespace
{
	int64_t solve_p2(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		utils::sorted_vector<int64_t> scores;
		utils::transform_if_post(ILI{ input }, ILI{}, std::back_inserter(scores), score_incomplete_line<5>,
			[](int64_t score) {return score > 0; });
		AdventCheck((scores.size() % 2) == 1);
		const std::size_t mid_idx = scores.size() / 2;
		return scores[mid_idx];
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"([({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<{}[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]{}
[[<[([]))<([[{}[[()]]]
[{[{({}]{}}([{[{{{}}([]
{<[[]]>}<{[{[{[]{()[[[]
[<(<(<(<{}))><([]([]()
<{([([[(<>()){}]>(<<{{
<{([{{}}[<[[[<>{}]]]>[]])"
		};
	}
}

ResultType day_ten_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_ten_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_ten_p1()
{
	auto input = advent::open_puzzle_input(10);
	return solve_p1(input);
}

ResultType advent_ten_p2()
{
	auto input = advent::open_puzzle_input(10);
	return solve_p2(input);
}

#undef DAY10DBG
#undef ENABLE_DAY10DBG