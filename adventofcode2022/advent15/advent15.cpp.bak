#include "advent15.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY15DBG 1
#ifdef NDEBUG
#define DAY15DBG 0
#else
#define DAY15DBG ENABLE_DAY15DBG
#endif

#if DAY15DBG
	#include <iostream>
#endif

namespace
{
#if DAY15DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <vector>
#include <algorithm>
#include <unordered_map>
#include <set>

#include <istream_line_iterator.h>
#include <coords.h>
#include <range_contains.h>
#include <small_vector.h>
#include <min_transform.h>
#include <swap_remove.h>
#include <transform_if.h>

namespace
{
	constexpr std::size_t SIZE_INCREASER = 5;
	using GridData = std::vector<uint8_t>;
	using utils::coords;

	enum class Day : char {one,two};

	struct Grid
	{
	private:
		friend Grid read_grid(std::istream& input, Day day);
		GridData data;
		std::size_t width = 0;
		Day day = Day::one;

		int get_scale() const
		{
			switch (day)
			{
			case Day::one:
				return 1;
			case Day::two:
				return SIZE_INCREASER;
			}
			AdventUnreachable();
			return 0;
		}

		std::size_t get_base_height() const
		{
			return data.size() / width;
		}

		std::size_t get_idx_base(coords c) const
		{
			constexpr std::size_t INVALID = std::numeric_limits<std::size_t>::max();
			if (!utils::range_contains_exc(c.x, 0, static_cast<int>(width)))
			{
				return INVALID;
			}

			if (c.y < 0) return INVALID;

			auto us = [](int i) {return static_cast<std::size_t>(i); };
			const std::size_t idx = us(c.y) * width + us(c.x);
			return idx < data.size() ? idx : INVALID;
		}

		bool validate_coords_base(const coords& c) const
		{
			const bool x_check = utils::range_contains_exc(c.x, 0, static_cast<int>(width));
			const bool y_check = utils::range_contains_exc(c.y, 0, static_cast<int>(get_base_height()));
			return x_check && y_check;
		}

		int get_base_cost(const coords& c) const
		{
			AdventCheck(validate_coords_base(c));
			const std::size_t idx = get_idx_base(c);
			AdventCheck(idx < data.size());
			const int result = data[idx];
			AdventCheck(utils::range_contains_inc(result, 0, 9));
			return result;
		}

		int get_cost_d1(const coords& c) const
		{
			AdventCheck(day == Day::one);
			return get_base_cost(c);
		}

		int get_cost_d2(const coords& c) const
		{
			AdventCheck(day == Day::two);
			AdventCheck(validate_coords(c));
			const int steps_right = c.x / width;
			const int steps_down = c.y / get_base_height();
			const int total_steps = steps_down + steps_right;

			const coords internal_coords{ static_cast<int>(c.x % width), static_cast<int>(c.y % get_base_height()) };
			const int cost = get_base_cost(internal_coords) + total_steps;
			return ((cost - 1) % 9) + 1;
		}

	public:
		std::size_t hash_coords(const coords& c) const
		{
			AdventCheck(validate_coords(c));
			const int hash = c.y * width * get_scale() + c.x;
			return static_cast<std::size_t>(hash);
		}

		std::size_t size() const
		{
			const std::size_t scale = static_cast<std::size_t>(get_scale());
			return data.size() * scale;
		}

		coords get_target() const
		{
			const auto s = [](std::size_t i) {return static_cast<int>(i); };
			const coords extents = coords{ s(width),s(get_base_height()) } * get_scale();
			return extents - coords{ 1,1 };
		}

		bool validate_coords(const coords& c) const
		{
			if (c.x < 0) return false;
			if (c.y < 0) return false;
			return validate_coords_base(c / get_scale());
		}

		int get_cost(const coords& c) const
		{
			AdventCheck(validate_coords(c));
			switch (day)
			{
			case Day::one:
				return get_cost_d1(c);
			case Day::two:
				return get_cost_d2(c);
			}
			AdventUnreachable();
			return 0;
		}

		template <typename F>
		void print(const F& func) const
		{
			const int x_max = static_cast<int>(width) * get_scale();
			const int y_max = static_cast<int>(get_base_height()) * get_scale();
			for (int y = 0; y < y_max; ++y)
			{
				log << '\n';
				for (int x = 0; x < x_max; ++x)
				{
					const coords c{ x,y };
					const bool p = func(c);
					const int cost = get_cost(c);
					const char p_cost = static_cast<char>(cost) + '0';
					log << (p ? p_cost : ' ');
				}
			}
		}

		void print() const
		{
			return print([](const coords& c) {return true; });
		}
	};

	int get_shortest_path(const Grid& grid)
	{
		const coords target = grid.get_target();

		struct Node
		{
			coords location;
			int cost;
			int plus_heuristic;
			std::size_t previous = std::numeric_limits<std::size_t>::max();
			bool operator<(const Node& other) const
			{
				return this->plus_heuristic < other.plus_heuristic;
				return cost < other.cost;
			}
		};

		const auto make_node = [&grid, &target](const coords& c, int cost)
		{
			AdventCheck(grid.validate_coords(c));
			return Node{
				c, cost, cost + c.manhatten_distance(target)
			};
		};

		const auto next_node = [&grid, &make_node](const coords& c, int base_cost, std::size_t previous)
		{
			AdventCheck(grid.validate_coords(c));
			Node result = make_node(c, base_cost + grid.get_cost(c));
			result.previous = previous;
			return result;
		};

		std::multiset<Node> unchecked_nodes{ make_node(coords{0,0},0) };
		std::unordered_map<std::size_t, Node> checked_nodes;

		const auto should_add_coords = [&checked_nodes, &grid](const coords& c)
		{
			if (!grid.validate_coords(c)) return false;
			const std::size_t hash = grid.hash_coords(c);
			const auto checked_it = checked_nodes.find(hash);
			return checked_it == end(checked_nodes);
		};

		while (!unchecked_nodes.empty())
		{
			//log << "\nNodes: checked=" << checked_nodes.size() << " Unchecked=" << unchecked_nodes.size();
			const Node node = *begin(unchecked_nodes);
			if (node.location == target)
			{
#if DAY15DBG
				std::vector<coords> path;
				Node pos = node;
				while (true)
				{
					path.push_back(pos.location);
					const auto prev_it = checked_nodes.find(pos.previous);
					if (prev_it != end(checked_nodes))
					{
						pos = prev_it->second;
					}
					else
					{
						break;
					}
				}
				std::ranges::sort(path);
				grid.print([&path](const coords& c)
				{
					return std::ranges::binary_search(path, c);
				});
#endif
				log << "\nTarget found. Checked " << checked_nodes.size() + 1 << " nodes.\n";
				return node.cost;
			}

			const std::size_t idx = grid.hash_coords(node.location);

			const auto next = [&node, &next_node, idx](const coords& c)
			{
				return next_node(c, node.cost, idx);
			};

			unchecked_nodes.erase(begin(unchecked_nodes));
			const auto neighbours = node.location.neighbours();
			utils::transform_if_pre(begin(neighbours), end(neighbours), std::inserter(unchecked_nodes,begin(unchecked_nodes)),
				next, should_add_coords);
		
			checked_nodes.insert(std::pair{ idx,node });
		}

		log << "\nTarget not found. Checked " << checked_nodes.size() << " nodes.\n";
		AdventUnreachable();
		return -1;
	}

	Grid read_grid(std::istream& input, Day day)
	{
		Grid result;
		result.day = day;
		for (std::string line : utils::line_range{ input })
		{
			if (result.data.empty())
			{
				const std::size_t w = line.size();
				result.width = w;
				result.data.reserve(w * w);
			}
			else
			{
				AdventCheck(result.width == line.size());
			}

			std::ranges::transform(line, std::back_inserter(result.data), [](char c)
			{
				AdventCheck(std::isdigit(c));
				return c - '0';
			});
		}

		if (day == Day::two)
		{
			
		}

		return result;
	}

	int solve_generic(std::istream& input, Day day)
	{
		const Grid grid = read_grid(input, day);
		return get_shortest_path(grid);
	}

	int solve_p1(std::istream& input)
	{
		return solve_generic(input, Day::one);
	}

	int solve_p2(std::istream& input)
	{
		return solve_generic(input, Day::two);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581)"
		};
	}
}

ResultType day_fifteen_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_fifteen_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_fifteen_p1()
{
	auto input = advent::open_puzzle_input(15);
	return solve_p1(input);
}

ResultType advent_fifteen_p2()
{
	auto input = advent::open_puzzle_input(15);
	return solve_p2(input);
}

#undef DAY15DBG
#undef ENABLE_DAY15DBG