#include "advent6.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY6DBG 1
#ifdef NDEBUG
#define DAY6DBG 0
#else
#define DAY6DBG ENABLE_DAY6DBG
#endif

#if DAY6DBG
	#include <iostream>
#endif

namespace
{
#if DAY6DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <algorithm>
#include <numeric>
#include <map>

#include <int_range.h>
#include <to_value.h>
#include <istream_line_iterator.h>

namespace
{
	using ValueType = int64_t;
	constexpr std::size_t MaxAge = 9;

	using PopulationProfile = std::array<ValueType, MaxAge>;

	struct ResultCacheID
	{
		int days_left;
		std::size_t new_time;
		std::size_t double_time;
		auto operator<=>(const ResultCacheID&) const = default;
	};

	using ResultCache = std::map<ResultCacheID, ValueType>;

	ValueType get_n_days_multiplier(int num_days, std::size_t new_time, std::size_t double_time, ResultCache& cache)
	{
		if (num_days <= 0) return 1;

		ResultCacheID id{ num_days,new_time,double_time };
		const auto cached_it = cache.find(id);
		if (cached_it != end(cache))
		{
			return cached_it->second;
		}

		const auto recurse = [num_days, new_time, double_time, &cache](std::size_t offset)
		{
			return get_n_days_multiplier(num_days - offset, new_time, double_time, cache);
		};

		const ValueType new_fish = recurse(new_time);
		const ValueType old_fish = recurse(double_time);
		const ValueType result = new_fish + old_fish;
		AdventCheck(result > 0);
		cache[id] = result;
		return result;
	}

	ValueType num_after_n_days(ValueType original, int num_days,std::size_t new_time, std::size_t double_time, ResultCache& cache)
	{
		return original * get_n_days_multiplier(num_days, new_time, double_time, cache);
	}

	ValueType get_population_after(const PopulationProfile& population, int num_days, std::size_t double_time,ResultCache& cache)
	{
		const auto range = utils::int_range{ population.size() };
		const ValueType result = std::transform_reduce(begin(range), end(range), ValueType{ 0 },
			std::plus<ValueType>{},
			[&population, num_days, double_time,&cache](std::size_t i)
		{
			const ValueType result = num_after_n_days(population[i], num_days - i, population.size(), double_time,cache);
			log << "\nDayLeft=" << i << " Num=" << result;
			return result;
		});
		return result;
	}

	PopulationProfile read_input(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		const PopulationProfile result = std::accumulate(ILI{ input,',' }, ILI{}, PopulationProfile{},
			[](PopulationProfile pop, std::string_view val)
		{
			const auto age = utils::to_value<std::size_t>(val);
			++pop[age];
			return pop;
		});
		return result;
	}

	ValueType solve_generic(std::istream& input, int num_days, std::size_t double_time)
	{
		ResultCache cache;
		const PopulationProfile pop = read_input(input);
		return get_population_after(pop, num_days, double_time, cache);
	}

	ValueType solve_p1_generic(std::istream& input, int num_days)
	{
		return solve_generic(input, num_days, 7);
	}

	ValueType solve_p1(std::istream& input)
	{
		return solve_p1_generic(input, 80);
	}

	ValueType solve_p2(std::istream& input)
	{
		return solve_p1_generic(input, 256);
	}

	std::istringstream testcase_a()
	{
		return std::istringstream{ "3,4,3,1,2" };
	}
}

ResultType advent6_internal::test_p1_a(int num_days)
{
	auto input = testcase_a();
	return solve_p1_generic(input, num_days);
}

ResultType advent_six_p1()
{
	auto input = advent::open_puzzle_input(6);
	return solve_p1(input);
}

ResultType advent_six_p2()
{
	auto input = advent::open_puzzle_input(6);
	return solve_p2(input);
}

#undef DAY6DBG
#undef ENABLE_DAY6DBG