#include "advent4.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY4DBG 1
#ifdef NDEBUG
#define DAY4DBG 0
#else
#define DAY4DBG ENABLE_DAY4DBG
#endif

#if DAY4DBG
	#include <iostream>
#endif

namespace
{
#if DAY4DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <algorithm>
#include <numeric>
#include <vector>
#include <sstream>

#include <int_range.h>
#include <range_contains.h>
#include <swap_remove.h>

namespace
{
	using ValueType = int;
	constexpr std::size_t BOARD_SIDE = 5;

	// Set a value to negative when it is marked.
	class BingoBoard
	{
	private:
		std::array<ValueType, BOARD_SIDE* BOARD_SIDE> m_data;
		void validate()
		{
			for (std::size_t outer = 0; outer < m_data.size(); ++outer)
			{
				const ValueType ref_val = m_data[outer];
				for (std::size_t inner = outer + 1; inner < m_data.size(); ++inner)
				{
					const ValueType comp_val = m_data[inner];
					AdventCheck(ref_val != comp_val);
				}
			}
		}

		static void validate_coord(std::size_t coord)
		{
			AdventCheck(utils::range_contains_exc<std::size_t>(coord, 0, BOARD_SIDE));
		}

		ValueType value_at(std::size_t row, std::size_t col) const
		{
			validate_coord(row);
			validate_coord(col);
			return m_data[row * BOARD_SIDE + col];
		}

		bool value_marked(std::size_t row, std::size_t col) const
		{
			return value_at(row, col) < 0;
		}

		bool row_marked(std::size_t row) const
		{
			utils::int_range range{ BOARD_SIDE };
			return std::all_of(begin(range),end(range), // Does not work with std::ranges version and I don't know why
				[this, row](std::size_t col)
			{
				return value_marked(row, col);
			});
		}

		bool col_marked(std::size_t col) const
		{
			utils::int_range range{ BOARD_SIDE };
			return std::all_of(begin(range),end(range),
				[this, col](std::size_t row)
			{
				return value_marked(row, col);
			});
		}

	public:
		BingoBoard(const BingoBoard&) = default;
		explicit BingoBoard(std::istream& data_stream)
		{
			std::copy_n(std::istream_iterator<int>{data_stream}, m_data.size(), begin(m_data));
			validate();
		}

		bool check_for_victory() const
		{
			utils::int_range range{ BOARD_SIDE };
			return std::any_of(begin(range), end(range),
				[this](std::size_t i)
			{
				return row_marked(i) || col_marked(i);
			});
		}

		bool check_off_number(ValueType val)
		{
			const auto it = std::ranges::find(m_data, val);
			if (it != end(m_data))
			{
				*it = -1;
				return true;
			}
			return false;
		}

		int get_unmarked_value_score() const
		{
			return std::transform_reduce(begin(m_data), end(m_data), 0, std::plus<int>{},
				[](ValueType v) -> int {return v < 0 ? 0 : v; });
		}
	};

	std::istringstream get_input_numbers(std::istream& input)
	{
		std::string line;
		std::getline(input, line);
		std::ranges::transform(line, begin(line), [](char c) {return c == ',' ? ' ' : c; });
		std::string dummy;
		std::getline(input,dummy);
		return std::istringstream{ std::move(line) };
	}

	std::vector<BingoBoard> get_boards(std::istream& input)
	{
		std::vector<BingoBoard> result;
		while (!input.eof())
		{
			result.emplace_back(input);
			std::string dummy;
			std::getline(input, dummy);
			std::getline(input, dummy);
		}
		return result;
	}

	enum class EndCondition : bool
	{
		first,
		last
	};

	// Returns the winning score
	template <EndCondition end_condition>
	int play_bingo(std::istream& numbers, std::vector<BingoBoard> boards)
	{
		using It = std::istream_iterator<int>;
		std::size_t num_checked = 0;
		for (auto it = It{ numbers }; it != It{}; it++)
		{
			const ValueType val = *it;
			bool found_any = false;
			for (BingoBoard& board : boards)
			{
				const bool found_one = board.check_off_number(val);
				found_any = found_any || found_one;
				if constexpr (end_condition == EndCondition::first)
				{
					if (num_checked >= BOARD_SIDE && found_one && board.check_for_victory())
					{
						return static_cast<int>(val) * board.get_unmarked_value_score();
					}
				}
			}

			if constexpr (end_condition == EndCondition::last)
			{
				if (num_checked >= BOARD_SIDE && found_any)
				{
					if (boards.size() == 1 && boards[0].check_for_victory())
					{
						return static_cast<int>(val) * boards[0].get_unmarked_value_score();
					}
					utils::swap_remove_if(boards, [](const BingoBoard& b) {return b.check_for_victory(); });
					AdventCheck(!boards.empty());
				}
			}
			++num_checked;
		}
		AdventUnreachable();
		return 0;
	}

	template <EndCondition end_condition>
	int solve_generic(std::istream& input)
	{
		auto numbers = get_input_numbers(input);
		auto boards = get_boards(input);
		return play_bingo<end_condition>(numbers, std::move(boards));
	}

	int solve_p1(std::istream& input)
	{
		return solve_generic<EndCondition::first>(input);
	}

	int solve_p2(std::istream& input)
	{
		return solve_generic<EndCondition::last>(input);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1

22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7)"
		};
	}
}

ResultType day_four_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_four_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_four_p1()
{
	auto input = advent::open_puzzle_input(4);
	return solve_p1(input);
}

ResultType advent_four_p2()
{
	auto input = advent::open_puzzle_input(4);
	return solve_p2(input);
}

#undef DAY4DBG
#undef ENABLE_DAY4DBG