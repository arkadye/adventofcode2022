#include "advent22.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY22DBG 1
#ifdef NDEBUG
#define DAY22DBG 0
#else
#define DAY22DBG ENABLE_DAY22DBG
#endif

#if DAY22DBG
	#include <iostream>
#endif

namespace
{
#if DAY22DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <small_vector.h>
#include <istream_line_iterator.h>
#include <to_value.h>
#include <range_contains.h>
#include <parse_utils.h>
#include <int_range.h>

#include <array>
#include <algorithm>
#include <vector>
#include <optional>
#include <string_view>

namespace
{
	using utils::small_vector;

	enum class Axis : char
	{
		x, y, z
	};

	constexpr std::array<Axis, 3> all_axes()
	{
		return { Axis::x,Axis::y,Axis::z };
	}

	struct Coord3D
	{
		int64_t x, y, z;
		Coord3D(int64_t x_, int64_t y_, int64_t z_) : x{ x_ }, y{ y_ }, z{ z_ }{}
		Coord3D() : Coord3D{ 0,0,0 } {}
		int64_t get(Axis axis) const
		{
			switch (axis)
			{
			case Axis::x:
				return x;
			case Axis::y:
				return y;
			case Axis::z:
				return z;
			}
			AdventUnreachable();
			return 0;
		}

		int64_t& get(Axis axis)
		{
			switch (axis)
			{
			case Axis::x:
				return x;
			case Axis::y:
				return y;
			case Axis::z:
				return z;
			}
			AdventUnreachable();
			return x;
		}
	};

	Coord3D operator-(const Coord3D& left, const Coord3D& right)
	{
		return Coord3D{ left.x - right.x,left.y - right.y,left.z - right.z };
	}

	struct Cube
	{
		// Lowest coords inside the cube.
		Coord3D mins;
			
		// First coords outside the cube.
		Coord3D maxs;

		int64_t volume() const
		{
			const Coord3D extents = maxs - mins;
			return extents.x * extents.y * extents.z;
		}
		bool is_valid() const
		{
			return maxs.x > mins.x
				&& maxs.y > mins.y
				&& maxs.z > mins.z;
		}
	};

	bool overlaps(const Cube& a, const Cube& b)
	{
		const auto axis_overlaps = [&](Axis axis)
		{
			if (a.mins.get(axis) >= b.maxs.get(axis))
			{
				return false;
			}
			if (b.mins.get(axis) >= a.maxs.get(axis))
			{
				return false;
			}
			return true;
		};

		return std::ranges::all_of(all_axes(), axis_overlaps);
	}

	small_vector<Cube, 2> bisect_cube(const Cube& cube, Axis axis, int64_t val)
	{
		AdventCheck(cube.is_valid());
		small_vector<Cube, 2> result;		
		result.push_back(cube);

		if (!utils::range_contains_exc(val, cube.mins.get(axis)+1, cube.maxs.get(axis)))
		{
			// Axis is not within the cube.
			return result;
		}

		result.push_back(cube);

		// Result has two identical cubes in it.
		AdventCheck(result.size() == 2);
		result[0].maxs.get(axis) = val;
		result[1].mins.get(axis) = val;

		AdventCheck(result[0].is_valid());
		AdventCheck(result[1].is_valid());

		return result;
	}

	bool envelops(const Cube& outer, const Cube& inner)
	{
		AdventCheck(outer.is_valid());
		AdventCheck(inner.is_valid());
		const auto axis_envelops = [&outer, &inner](Axis axis)
		{
			return outer.mins.get(axis) <= inner.mins.get(axis)
				&& outer.maxs.get(axis) >= inner.maxs.get(axis);
		};
		return std::ranges::all_of(all_axes(), axis_envelops);
	}

	small_vector<Cube, 6> make_space(const Cube& original, const Cube& space)
	{
		AdventCheck(original.is_valid());
		AdventCheck(space.is_valid());

		small_vector<Cube, 6> result;

		if (envelops(space, original))
		{
			return result;
		}

		if (!overlaps(original, space))
		{
			result.push_back(original);
			return result;
		}

		Cube candidate_area = original;

		const auto bisect_extent = [&result, &candidate_area, &space](Axis axis, bool is_max)
		{
			const Coord3D extent = is_max ? space.maxs : space.mins;
			const int64_t boundary = extent.get(axis);
			const int64_t candidate_min = candidate_area.mins.get(axis)+1;
			const int64_t candidate_max = candidate_area.maxs.get(axis);
			if (utils::range_contains_exc(boundary, candidate_min, candidate_max))
			{
				const auto split = bisect_cube(candidate_area, axis, boundary);
				AdventCheck(split.size() == 2);
				AdventCheck(split[0].is_valid());
				AdventCheck(split[1].is_valid());
				candidate_area = is_max ? split[0] : split[1];
				result.push_back(is_max ? split[1] : split[0]);
			}
		};

		for (Axis axis : all_axes())
		{
			bisect_extent(axis, false);
			bisect_extent(axis, true);
		}

		return result;
	}

	void validate_map(const std::vector<Cube>& map)
	{
		for (auto left_it = begin(map); left_it != end(map); ++left_it)
		{
			for (auto right_it = left_it + 1; right_it != end(map); ++right_it)
			{
				AdventCheck(!overlaps(*left_it, *right_it));
			}
		}
	}

	std::vector<Cube> get_cube_map(const std::vector<Cube>& input_map, const Cube& new_cube, bool turning_on)
	{
		std::vector<Cube> result;
		result.reserve(2 * input_map.size());

		if (turning_on)
		{
			result.push_back(new_cube);
		}

		for (const Cube& old : input_map)
		{
			const auto split = make_space(old, new_cube);
			std::copy(begin(split), end(split), std::back_inserter(result));
			validate_map(result);
		}

		return result;
	}

	std::optional<Cube> intersection(const Cube& a, const Cube& b)
	{
		Cube result;
		const auto set_axis = [&result, &a, &b](Axis axis)
		{
			result.mins.get(axis) = std::max(a.mins.get(axis), b.mins.get(axis));
			result.maxs.get(axis) = std::min(a.maxs.get(axis), b.maxs.get(axis));
		};

		for (Axis a : all_axes())
		{
			set_axis(a);
		}

		if (result.is_valid())
		{
			return result;
		}
		else
		{
			return std::nullopt;
		}
	}

	struct Range
	{
		int64_t low, high;
		Range(int64_t l, int64_t h) : low{ l }, high{ h }
		{
			AdventCheck(l < h);
		}
	};

	Range read_range(std::string_view input)
	{
		using utils::to_value;
		const auto split = utils::split_string_at_first(input, "..");
		const auto lower = to_value<int64_t>(split.first);
		const auto higher = to_value<int64_t>(split.second) + 1;
		return Range{ lower,higher };
	}

	struct AxisData
	{
		Range range;
		Axis axis;
	};

	AxisData read_axis(std::string_view input)
	{
		const auto [axis, range] = utils::split_string_at_first(input, '=');

		const auto get_axis = [axis]()
		{
			AdventCheck(axis.size() == 1);
			switch (axis.front())
			{
			case 'x':
				return Axis::x;
			case 'y':
				return Axis::y;
			case 'z':
				return Axis::z;
			default:
				AdventUnreachable();
				break;
			}
			AdventUnreachable();
			return Axis::x;
		};

		return AxisData{ read_range(range),get_axis() };
	}

	Cube read_cube(std::string_view input)
	{
		const auto axis_data_strings = utils::get_string_elements(input, ',', 0, 1, 2);
		small_vector<AxisData, 3> axis_data;
		std::transform(begin(axis_data_strings), end(axis_data_strings), std::back_inserter(axis_data), read_axis);

		Cube result;
		const auto axes = all_axes();
		for (auto i : utils::int_range{ axes.size() })
		{
			AdventCheck(i < axis_data.size());
			AdventCheck(i < axes.size());
			const Axis a = axes[i];
			const AxisData& data = axis_data[i];
			AdventCheck(data.axis == a);
			result.mins.get(a) = data.range.low;
			result.maxs.get(a) = data.range.high;
		}
		return result;
	}

	struct Operation
	{
		Cube cube;
		bool turn_on;
	};

	Operation read_line(std::string_view input)
	{
		const auto [on_off, cube] = utils::split_string_at_first(input, ' ');
		Operation result;
		result.cube = read_cube(cube);
		
		const std::array<std::string_view, 2> valid_ops{ "on","off" };
		AdventCheck(std::ranges::count(valid_ops, on_off) == 1);
		result.turn_on = (on_off == "on");
		return result;
	}

	std::vector<Cube> get_on_lights(std::optional<Cube> extents, std::istream& instructions)
	{
		std::vector<Cube> result;
		for (std::string line : utils::line_range{ instructions })
		{
			const Operation op = read_line(line);
			const std::optional<Cube> area = [&extents, &op]() -> std::optional<Cube>
			{
				if (extents.has_value())
				{
					return intersection(op.cube, *extents);
				}
				return op.cube;
			}();

			if (area.has_value())
			{
				result = get_cube_map(result, *area, op.turn_on);
			}
		}
		validate_map(result);
		return result;
	}

	int64_t count_on_lights(const std::vector<Cube>& on)
	{
		validate_map(on);
		return std::transform_reduce(begin(on), end(on), int64_t{ 0 },
			std::plus<int64_t>{}, [](const Cube& c) {return c.volume(); });
	}

	int64_t solve_generic(std::optional<Cube> extents, std::istream& input)
	{
		const auto map = get_on_lights(extents, input);
		return count_on_lights(map);
	}

	int64_t solve_p1(std::istream& input)
	{
		const Cube extents{
			Coord3D{-50,-50,-50},
			Coord3D{51,51,51}
		};
		return solve_generic(extents, input);
	}
}

namespace
{
	int64_t solve_p2(std::istream& input)
	{
		return solve_generic(std::nullopt, input);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(on x=10..12,y=10..12,z=10..12
on x=11..13,y=11..13,z=11..13
off x=9..11,y=9..11,z=9..11
on x=10..10,y=10..10,z=10..10)"
		};
	}

	std::istringstream testcase_b()
	{
		return std::istringstream{
			R"(on x=-20..26,y=-36..17,z=-47..7
on x=-20..33,y=-21..23,z=-26..28
on x=-22..28,y=-29..23,z=-38..16
on x=-46..7,y=-6..46,z=-50..-1
on x=-49..1,y=-3..46,z=-24..28
on x=2..47,y=-22..22,z=-23..27
on x=-27..23,y=-28..26,z=-21..29
on x=-39..5,y=-6..47,z=-3..44
on x=-30..21,y=-8..43,z=-13..34
on x=-22..26,y=-27..20,z=-29..19
off x=-48..-32,y=26..41,z=-47..-37
on x=-12..35,y=6..50,z=-50..-2
off x=-48..-32,y=-32..-16,z=-15..-5
on x=-18..26,y=-33..15,z=-7..46
off x=-40..-22,y=-38..-28,z=23..41
on x=-16..35,y=-41..10,z=-47..6
off x=-32..-23,y=11..30,z=-14..3
on x=-49..-5,y=-3..45,z=-29..18
off x=18..30,y=-20..-8,z=-3..13
on x=-41..9,y=-7..43,z=-33..15
on x=-54112..-39298,y=-85059..-49293,z=-27449..7877
on x=967..23432,y=45373..81175,z=27513..53682)"
		};
	}

	std::istringstream testcase_c()
	{
		return std::istringstream{
			R"(on x=-5..47,y=-31..22,z=-19..33
on x=-44..5,y=-27..21,z=-14..35
on x=-49..-1,y=-11..42,z=-10..38
on x=-20..34,y=-40..6,z=-44..1
off x=26..39,y=40..50,z=-2..11
on x=-41..5,y=-41..6,z=-36..8
off x=-43..-33,y=-45..-28,z=7..25
on x=-33..15,y=-32..19,z=-34..11
off x=35..47,y=-46..-34,z=-11..5
on x=-14..36,y=-6..44,z=-16..29
on x=-57795..-6158,y=29564..72030,z=20435..90618
on x=36731..105352,y=-21140..28532,z=16094..90401
on x=30999..107136,y=-53464..15513,z=8553..71215
on x=13528..83982,y=-99403..-27377,z=-24141..23996
on x=-72682..-12347,y=18159..111354,z=7391..80950
on x=-1060..80757,y=-65301..-20884,z=-103788..-16709
on x=-83015..-9461,y=-72160..-8347,z=-81239..-26856
on x=-52752..22273,y=-49450..9096,z=54442..119054
on x=-29982..40483,y=-108474..-28371,z=-24328..38471
on x=-4958..62750,y=40422..118853,z=-7672..65583
on x=55694..108686,y=-43367..46958,z=-26781..48729
on x=-98497..-18186,y=-63569..3412,z=1232..88485
on x=-726..56291,y=-62629..13224,z=18033..85226
on x=-110886..-34664,y=-81338..-8658,z=8914..63723
on x=-55829..24974,y=-16897..54165,z=-121762..-28058
on x=-65152..-11147,y=22489..91432,z=-58782..1780
on x=-120100..-32970,y=-46592..27473,z=-11695..61039
on x=-18631..37533,y=-124565..-50804,z=-35667..28308
on x=-57817..18248,y=49321..117703,z=5745..55881
on x=14781..98692,y=-1341..70827,z=15753..70151
on x=-34419..55919,y=-19626..40991,z=39015..114138
on x=-60785..11593,y=-56135..2999,z=-95368..-26915
on x=-32178..58085,y=17647..101866,z=-91405..-8878
on x=-53655..12091,y=50097..105568,z=-75335..-4862
on x=-111166..-40997,y=-71714..2688,z=5609..50954
on x=-16602..70118,y=-98693..-44401,z=5197..76897
on x=16383..101554,y=4615..83635,z=-44907..18747
off x=-95822..-15171,y=-19987..48940,z=10804..104439
on x=-89813..-14614,y=16069..88491,z=-3297..45228
on x=41075..99376,y=-20427..49978,z=-52012..13762
on x=-21330..50085,y=-17944..62733,z=-112280..-30197
on x=-16478..35915,y=36008..118594,z=-7885..47086
off x=-98156..-27851,y=-49952..43171,z=-99005..-8456
off x=2032..69770,y=-71013..4824,z=7471..94418
on x=43670..120875,y=-42068..12382,z=-24787..38892
off x=37514..111226,y=-45862..25743,z=-16714..54663
off x=25699..97951,y=-30668..59918,z=-15349..69697
off x=-44271..17935,y=-9516..60759,z=49131..112598
on x=-61695..-5813,y=40978..94975,z=8655..80240
off x=-101086..-9439,y=-7088..67543,z=33935..83858
off x=18020..114017,y=-48931..32606,z=21474..89843
off x=-77139..10506,y=-89994..-18797,z=-80..59318
off x=8476..79288,y=-75520..11602,z=-96624..-24783
on x=-47488..-1262,y=24338..100707,z=16292..72967
off x=-84341..13987,y=2429..92914,z=-90671..-1318
off x=-37810..49457,y=-71013..-7894,z=-105357..-13188
off x=-27365..46395,y=31009..98017,z=15428..76570
off x=-70369..-16548,y=22648..78696,z=-1892..86821
on x=-53470..21291,y=-120233..-33476,z=-44150..38147
off x=-93533..-4276,y=-16170..68771,z=-104985..-24507)"
		};
	}
}

ResultType day_twentytwo_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_twentytwo_p1_b()
{
	auto input = testcase_b();
	return solve_p1(input);
}

ResultType day_twentytwo_p1_c()
{
	auto input = testcase_c();
	return solve_p1(input);
}

ResultType day_twentytwo_p2_c()
{
	auto input = testcase_c();
	return solve_p2(input);
}

ResultType advent_twentytwo_p1()
{
	auto input = advent::open_puzzle_input(22);
	return solve_p1(input);
}

ResultType advent_twentytwo_p2()
{
	auto input = advent::open_puzzle_input(22);
	return solve_p2(input);
}

#undef DAY22DBG
#undef ENABLE_DAY22DBG