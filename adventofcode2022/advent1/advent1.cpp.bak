#include "advent1.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY1DBG 1
#ifdef NDEBUG
#define DAY1DBG 0
#else
#define DAY1DBG ENABLE_DAY1DBG
#endif

#if DAY1DBG
	#include <iostream>
#endif

namespace
{
#if DAY1DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <algorithm>
#include <numeric>
#include <sstream>

namespace
{
	template <int WINDOW>
	int solve_generic(std::istream& input)
	{
		using InputIt = std::istream_iterator<int>;
		std::array<int, WINDOW> previous = {};
		std::copy_n(InputIt{ input }, previous.size(), begin(previous));
		int last_count = std::accumulate(begin(previous), end(previous), 0);
		int result = 0;
		for (auto it = InputIt{ input }; it != InputIt{}; it++)
		{
			const int next_val = *it;
			const int next_count = last_count - previous.front() + next_val;
			if (next_count > last_count)
			{
				++result;
			}

			last_count = next_count;
			std::rotate(begin(previous), begin(previous) + 1, end(previous));
			previous.back() = next_val;
		}
		return result;
	}

	int solve_p1(std::istream& input)
	{
		return solve_generic<1>(input);
	}
}

namespace
{
	int solve_p2(std::istream& input)
	{
		return solve_generic<3>(input);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			"199\n"
			"200\n"
			"208\n"
			"210\n"
			"200\n"
			"207\n"
			"240\n"
			"269\n"
			"260\n"
			"263"
		};
	}
}

ResultType day_one_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_one_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_one_p1()
{
	auto input = advent::open_puzzle_input(1);
	return solve_p1(input);
}

ResultType advent_one_p2()
{
	auto input = advent::open_puzzle_input(1);
	return solve_p2(input);
}

#undef DAY1DBG
#undef ENABLE_DAY1DBG