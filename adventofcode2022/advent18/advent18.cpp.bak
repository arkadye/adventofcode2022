#include "advent18.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY18DBG 1
#ifdef NDEBUG
#define DAY18DBG 0
#else
#define DAY18DBG ENABLE_DAY18DBG
#endif

#if DAY18DBG
	#include <iostream>
#endif

namespace
{
#if DAY18DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <string>
#include <optional>
#include <memory>
#include <sstream>
#include <string_view>
#include <algorithm>
#include <vector>

#include <range_contains.h>
#include <brackets.h>
#include <to_value.h>
#include <parse_utils.h>
#include <istream_line_iterator.h>
#include <int_range.h>
#include <min_transform.h>

namespace
{
	constexpr char OPEN = '[';
	constexpr char CLOSE = ']';
	constexpr char DELIM = ',';

	enum class OperationResultType : char
	{
		no_action,
		action_required,
		action_handled,
		pass_left,
		pass_right
	};

	int mag(int i)
	{
		return i;
	}

	int mag(int l, int r)
	{
		return 3 * l + 2 * r;
	}

	struct OperationResult
	{
		int left_arg = 0;
		int right_arg = 0;
		OperationResultType type = OperationResultType::no_action;
	};

	class SnailfishBase
	{
	public:
		virtual std::string print() const = 0;
		virtual OperationResult try_explode(int depth) { return OperationResult{}; }
		virtual OperationResult try_split() { return OperationResult{}; }
		virtual void apply_explode_from_left(int amount) = 0;
		virtual void apply_explode_from_right(int amount) = 0;
		virtual bool is_int() const { return false; }
		virtual bool is_pair() const { return false; }
		virtual int magnitude() const = 0;
	};

	using SnailfishNumber = std::unique_ptr<SnailfishBase>;

	class SnailfishInt : public SnailfishBase
	{
	private:
		int val = 0;
		void apply_explode(int amount) { val += amount; }
	public:
		explicit SnailfishInt(int init = 0) : val{ init } {}
		bool is_int() const override { return true; }
		std::string print() const override { return std::to_string(val); }
		void apply_explode_from_left(int amount) override { apply_explode(amount); }
		void apply_explode_from_right(int amount) override { apply_explode(amount); }
		int magnitude() const override { return mag(val); }
		OperationResult try_split() override
		{
			if (val < 10) return OperationResult{};
			OperationResult result;
			result.type = OperationResultType::action_required;
			result.left_arg = val / 2;
			const bool is_odd = (val % 2);
			result.right_arg = (val / 2) + (is_odd ? 1 : 0);
			return result;
		}
		static SnailfishNumber make(int value)
		{
			return SnailfishNumber{ new SnailfishInt{value} };
		}
	};

	class SnailfishPair : public SnailfishBase
	{
	private:
		SnailfishNumber left;
		SnailfishNumber right;
		void verify() const
		{
			AdventCheck(left.get() != nullptr);
			AdventCheck(right.get() != nullptr);
		}
	public:
		SnailfishPair(SnailfishNumber&& l_init, SnailfishNumber&& r_init) : left{ std::move(l_init) }, right{ std::move(r_init) }{}
		bool is_pair() const override { return true; }
		std::string print() const override
		{
			verify();
			std::ostringstream result;
			result << OPEN << left->print() << DELIM << right->print() << CLOSE;
			return result.str();
		}
		OperationResult try_explode(int depth) override
		{
			verify();
			OperationResult result;

			// If we're deep enough to explode check we can and do it now.
			if (depth >= 4)
			{
				if (left->is_int() && right->is_int())
				{
					result.type = OperationResultType::action_required;
					result.left_arg = left->magnitude();
					result.right_arg = right->magnitude();
				}
				return result;
			}

			result = left->try_explode(depth + 1);
			switch (result.type)
			{
			case OperationResultType::no_action:
				break;
			case OperationResultType::action_required:
				right->apply_explode_from_left(result.right_arg);
				result.type = OperationResultType::pass_left;
				left = SnailfishInt::make(0);
				return result;
			case OperationResultType::action_handled:
			case OperationResultType::pass_left:
				return result;
			case OperationResultType::pass_right:
				right->apply_explode_from_left(result.right_arg);
				result.type = OperationResultType::action_handled;
				return result;
			}

			result = right->try_explode(depth + 1);
			switch (result.type)
			{
			case OperationResultType::no_action:
				break;
			case OperationResultType::action_required:
				left->apply_explode_from_right(result.left_arg);
				result.type = OperationResultType::pass_right;
				right = SnailfishInt::make(0);
				return result;
			case OperationResultType::action_handled:
			case OperationResultType::pass_right:
				return result;
			case OperationResultType::pass_left:
				left->apply_explode_from_right(result.left_arg);
				result.type = OperationResultType::action_handled;
				return result;
			}
			return result;
		}

		OperationResult try_split() override
		{
			verify();
			OperationResult result = left->try_split();
			switch (result.type)
			{
			case OperationResultType::no_action:
				break;
			case OperationResultType::action_handled:
				return result;
			case OperationResultType::action_required:
				left = SnailfishPair::make(result.left_arg, result.right_arg);
				result.type = OperationResultType::action_handled;
				return result;
			default:
				AdventUnreachable();
				break;
			}

			result = right->try_split();
			switch (result.type)
			{
			case OperationResultType::no_action:
				break;
			case OperationResultType::action_handled:
				return result;
			case OperationResultType::action_required:
				right = SnailfishPair::make(result.left_arg, result.right_arg);
				result.type = OperationResultType::action_handled;
				return result;
			default:
				AdventUnreachable();
				break;
			}

			return result;
		}

		void apply_explode_from_left(int amount) override
		{
			verify();
			left->apply_explode_from_left(amount);
		}

		void apply_explode_from_right(int amount) override
		{
			verify();
			right->apply_explode_from_right(amount);
		}

		int magnitude() const override
		{
			verify();
			return mag(left->magnitude(), right->magnitude());
		}

		static SnailfishNumber make(SnailfishNumber&& left, SnailfishNumber&& right)
		{
			return SnailfishNumber{ new SnailfishPair{std::move(left),std::move(right)} };
		}

		static SnailfishNumber make(int left, int right)
		{
			SnailfishNumber l = SnailfishInt::make(left);
			SnailfishNumber r = SnailfishInt::make(right);
			return make(std::move(l), std::move(r));
		}
	};

	SnailfishNumber reduce(SnailfishNumber&& number)
	{
		while (true)
		{
			AdventCheck(number.get() != nullptr);
			OperationResult result = number->try_explode(0);
			switch (result.type)
			{
			case OperationResultType::action_handled:
			case OperationResultType::pass_left:
			case OperationResultType::pass_right:
				continue;
			case OperationResultType::no_action:
				break;
			default:
				AdventUnreachable();
				return number;
			}

			result = number->try_split();
			switch (result.type)
			{
			case OperationResultType::action_handled:
				continue;
			case OperationResultType::no_action:
				break;
			default:
				AdventUnreachable();
				return number;
			}
			return number;
		}
	}

	SnailfishNumber add(SnailfishNumber&& left, SnailfishNumber&& right)
	{
		SnailfishNumber result = SnailfishPair::make(std::move(left), std::move(right));
		return reduce(std::move(result));
	}

	SnailfishNumber parse(std::string_view sv)
	{
		AdventCheck(!sv.empty());
		if (utils::is_value(sv))
		{
			return SnailfishInt::make(utils::to_value<int>(sv));
		}
		else
		{
			sv = utils::remove_specific_prefix(sv, std::string_view(&OPEN, 1));
			sv = utils::remove_specific_suffix(sv, std::string_view(&CLOSE, 1));
			
			const std::size_t split_point = utils::bracket_aware_find(sv, OPEN, CLOSE, DELIM);
			AdventCheck(split_point < sv.size());
			const auto [left,right] = utils::split_string_at_point(sv, split_point);
			return SnailfishPair::make(parse(left), parse(right));
		}
	}

	SnailfishNumber add_list(std::istream& input)
	{
		SnailfishNumber number = [&input]()
		{
			std::string line;
			std::getline(input, line);
			return parse(line);
		}();

		for (const std::string& line : utils::line_range{ input })
		{
			number = add(std::move(number), parse(line));
		}
		return number;
	}

	int solve_p1(std::istream& input)
	{
		SnailfishNumber number = add_list(input);
		return number->magnitude();
	}
}

namespace
{
	int solve_p2(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		std::vector<std::string> lines;
		std::copy(ILI{ input }, ILI{}, std::back_inserter(lines));
		utils::int_range range{ lines.size() };
		int best = std::numeric_limits<int>::min();
		for (std::size_t left : range)
		{
			for (std::size_t right : range)
			{
				std::string_view l{ lines[left] };
				std::string_view r{ lines[right] };
				SnailfishNumber num = add(parse(l), parse(r));
				best = std::max(best, num->magnitude());
			}
		}
		return best;
	}
}

namespace
{
	std::string explode_test(std::string_view input)
	{
		SnailfishNumber test = parse(input);
		test->try_explode(0);
		return test->print();
	}

	int magnitude_test(std::string_view input)
	{
		SnailfishNumber test = parse(input);
		return test->magnitude();
	}

	std::string add_test(std::string_view left, std::string_view right)
	{
		SnailfishNumber result = add(parse(left), parse(right));
		return result->print();
	}

	std::istringstream testcase()
	{
		return std::istringstream{
			R"([[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
[[[5,[2,8]],4],[5,[[9,9],0]]]
[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
[[[[5,4],[7,7]],8],[[8,3],8]]
[[9,3],[[9,9],[6,[4,9]]]]
[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]])"
		};
	}
}

ResultType day_eighteen_p1_a()
{
	return add_test("[1,2]", "[[3,4],5]");
}


ResultType day_eighteen_p1_b()
{
	return explode_test("[[[[[9,8],1],2],3],4]");
}

ResultType day_eighteen_p1_c()
{
	return explode_test("[7,[6,[5,[4,[3,2]]]]]");
}

ResultType day_eighteen_p1_d()
{
	return explode_test("[[6,[5,[4,[3,2]]]],1]");
}

ResultType day_eighteen_p1_e()
{
	return explode_test("[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]");
}

ResultType day_eighteen_p1_f()
{
	return explode_test("[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]");
}

ResultType day_eighteen_p1_g()
{
	return add_test("[[[[4,3],4],4],[7,[[8,4],9]]]","[1,1]");
}

ResultType day_eighteen_p1_h()
{
	std::istringstream input{
		R"([1,1]
[2,2]
[3,3]
[4,4])"
	};
	SnailfishNumber result = add_list(input);
	return result->print();
}

ResultType day_eighteen_p1_i()
{
	std::istringstream input{
		R"([1,1]
[2,2]
[3,3]
[4,4]
[5,5])"
	};
	SnailfishNumber result = add_list(input);
	return result->print();
}

ResultType day_eighteen_p1_j()
{
	std::istringstream input{
		R"([1,1]
[2,2]
[3,3]
[4,4]
[5,5]
[6,6])"
	};
	SnailfishNumber result = add_list(input);
	return result->print();
}

ResultType day_eighteen_p1_k()
{
	std::istringstream input{
		R"([[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]
[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]
[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]
[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]
[7,[5,[[3,8],[1,4]]]]
[[2,[2,2]],[8,[8,1]]]
[2,9]
[1,[[[9,3],9],[[9,0],[0,7]]]]
[[[5,[7,4]],7],1]
[[[[4,2],2],6],[8,7]])"
	};
	SnailfishNumber result = add_list(input);
	return result->print();
}

ResultType day_eighteen_p1_l()
{
	return magnitude_test("[9,1]");
}

ResultType day_eighteen_p1_m()
{
	return magnitude_test("[1,9]");
}

ResultType day_eighteen_p1_n()
{
	return magnitude_test("[[9,1],[1,9]]");
}

ResultType day_eighteen_p1_o()
{
	return magnitude_test("[[1,2],[[3,4],5]]");
}

ResultType day_eighteen_p1_p()
{
	return magnitude_test("[[[[0,7],4],[[7,8],[6,0]]],[8,1]]");
}

ResultType day_eighteen_p1_q()
{
	return magnitude_test("[[[[1,1],[2,2]],[3,3]],[4,4]]");
}

ResultType day_eighteen_p1_r()
{
	return magnitude_test("[[[[3,0],[5,3]],[4,4]],[5,5]]");
}

ResultType day_eighteen_p1_s()
{
	return magnitude_test("[[[[5,0],[7,4]],[5,5]],[6,6]]");
}

ResultType day_eighteen_p1_t()
{
	return magnitude_test("[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]");
}

ResultType day_eighteen_p1_u()
{
	auto input = testcase();
	SnailfishNumber result = add_list(input);
	return result->print();
}

ResultType day_eighteen_p1_v()
{
	auto input = testcase();
	return solve_p1(input);
}

ResultType day_eighteen_p2_a()
{
	auto input = testcase();
	return solve_p2(input);
}

ResultType day_eighteen_split_test(int input)
{
	SnailfishNumber test = SnailfishInt::make(input);
	const OperationResult result = test->try_split();
	if (result.type == OperationResultType::action_required)
	{
		test = SnailfishPair::make(result.left_arg, result.right_arg);
	}
	return test->print();
}

ResultType advent_eighteen_p1()
{
	auto input = advent::open_puzzle_input(18);
	return solve_p1(input);
}

ResultType advent_eighteen_p2()
{
	auto input = advent::open_puzzle_input(18);
	return solve_p2(input);
}

#undef DAY18DBG
#undef ENABLE_DAY18DBG