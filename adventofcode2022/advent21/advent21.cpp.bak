#include "advent21.h"
#include "../advent/advent_utils.h"
#include "sorted_vector.h"

#define ENABLE_DAY21DBG 1
#ifdef NDEBUG
#define DAY21DBG 0
#else
#define DAY21DBG ENABLE_DAY21DBG
#endif

#if DAY21DBG
	#include <iostream>
#endif

namespace
{
#if DAY21DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <string_view>
#include <map>

#include <int_range.h>
#include <range_contains.h>
#include <to_value.h>
#include <parse_utils.h>
#include <small_vector.h>
#include <istream_line_iterator.h>
#include <range_contains.h>

namespace
{
	constexpr int GAME_SIZE = 10;
	constexpr int ROLLS_PER_TURN = 3;
	constexpr int NUM_PLAYERS = 2;
	constexpr int WINNING_SCORE_P1 = 1000;

	using utils::range_contains_exc;

	int get_score_from_square(int square)
	{
		AdventCheck(range_contains_exc(square, 0, GAME_SIZE));
		return square != 0 ? square : GAME_SIZE;
	}

	using DieCache = std::array<int, GAME_SIZE>;

	DieCache make_die_cache()
	{
		DieCache result;
		for (auto init : utils::int_range{ GAME_SIZE })
		{
			result[init] = ROLLS_PER_TURN * init + (ROLLS_PER_TURN * (ROLLS_PER_TURN - 1)) / 2;
			result[init] %= GAME_SIZE;
		}
		return result;
	}

	int move_for_turn(const DieCache& cache, int die_init)
	{
		AdventCheck(die_init >= 0);
		const std::size_t init = static_cast<std::size_t>(die_init % GAME_SIZE);
		AdventCheck(range_contains_exc(init, std::size_t{ 0 }, cache.size()));
		const int result = cache[init];
		AdventCheck(range_contains_exc(result,0,GAME_SIZE));
		return result;
	}

	using TurnCache = std::array<int, GAME_SIZE* GAME_SIZE>;

	std::size_t get_turn_cache_idx(int square, int die)
	{
		return square * GAME_SIZE + (die % 10);
	}

	TurnCache make_turn_cache()
	{
		const auto game_range = utils::int_range{ GAME_SIZE };
		const DieCache die_cache = make_die_cache();
		TurnCache result;
		for (auto square : game_range)
		{
			for (auto die : game_range)
			{
				const auto idx = get_turn_cache_idx(square, die);
				const int new_square = (square + move_for_turn(die_cache,die)) % GAME_SIZE;
				result[idx] = new_square;
			}
		}
		return result;
	}

	struct PlayerStateP1
	{
		int square = 0;
		int score = 0;
	};

	auto operator<=>(const PlayerStateP1& left, const PlayerStateP1& right) noexcept
	{
		const auto sq_result = left.square <=> right.square;
		if (sq_result == std::strong_ordering::equivalent)
		{
			return left.score <=> right.score;
		}
		return sq_result;
	}

	void player_move(const TurnCache& cache, PlayerStateP1& state, int die_state)
	{
		const auto cache_idx = get_turn_cache_idx(state.square, die_state);
		AdventCheck(cache_idx < cache.size());
		state.square = cache[cache_idx];
		state.score += get_score_from_square(state.square);
	}

	struct GameStateP1
	{
		utils::small_vector<PlayerStateP1, NUM_PLAYERS> player_states;
		int num_die_rolls = 0;
		std::size_t next_move = 0;
	};

	void next_move(const TurnCache& cache, GameStateP1& state)
	{
		AdventCheck(state.next_move < state.player_states.size());
		player_move(cache, state.player_states[state.next_move], state.num_die_rolls + 1);
		++state.next_move;
		state.next_move %= state.player_states.size();
		state.num_die_rolls += ROLLS_PER_TURN;
	}

	GameStateP1 play_game(const utils::small_vector<int, NUM_PLAYERS>& initial_positions, int target_score)
	{
		const TurnCache cache = make_turn_cache();
		GameStateP1 state;
		std::transform(begin(initial_positions), end(initial_positions), std::back_inserter(state.player_states),
			[](int start_pos)
		{
			PlayerStateP1 result;
			result.square = start_pos;
			result.score = 0;
			return result;
		});

		while (std::all_of(begin(state.player_states), end(state.player_states),
			[target_score](const PlayerStateP1& ps) {return ps.score < target_score; }))
		{
			next_move(cache, state);
		}
		return state;
	}

	int get_start_position(int player_num, std::string_view line)
	{
		const auto [player_num_str, start_pos_str] = utils::get_string_elements(line, 1, 4);
		AdventCheck(player_num == utils::to_value<int>(player_num_str));
		return utils::to_value<int>(start_pos_str);
	}

	utils::small_vector<int, NUM_PLAYERS> get_start_positions(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		utils::small_vector<int, NUM_PLAYERS> result;
		int i = 0;
		std::transform(ILI{ input }, ILI{}, std::back_inserter(result), [&i](std::string_view line)
		{
			return get_start_position(++i, line);
		});
		return result;
	}

	int solve_p1(std::istream& input)
	{
		const auto start_positions = get_start_positions(input);
		const GameStateP1 result_state = play_game(start_positions, WINNING_SCORE_P1);

		int winning_score = 0;
		int total_scores = 0;
		for (const auto& ps : result_state.player_states)
		{
			total_scores += ps.score;
			winning_score = std::max(winning_score, ps.score);
		}

		return (total_scores - winning_score) * result_state.num_die_rolls;
	}
}

namespace
{
	constexpr int WINNING_SCORE_P2 = 21;
	constexpr int MIN_ROLL = 1;
	constexpr int MAX_ROLL = 3;

	struct PlayerStateP2
	{
	public:
		uint8_t get_hash() const { return hash; }
		int get_score() const { return hash / GAME_SIZE; }
		int get_square() const { return hash % GAME_SIZE; }
		void set_score(int new_score)
		{
			const int square = get_square();
			set_state(new_score, square);
		}
		void set_square(int new_square)
		{
			const int score = get_score();
			set_state(score, new_square);
		}
		void set_state(int score, int square)
		{
			AdventCheck(utils::range_contains_exc(square, 0, GAME_SIZE));
			AdventCheck(utils::range_contains_exc(score, 0, WINNING_SCORE_P2));
			const int new_hash = score * GAME_SIZE + square;
			constexpr int MAX_HASH = std::numeric_limits<uint8_t>::max();
			AdventCheck(utils::range_contains_inc(new_hash, 0, MAX_HASH));
			hash = static_cast<uint8_t>(new_hash);
		}
		// True if this would win the game.
		bool try_turn(int dice_total)
		{
			const int previous_square = get_square();
			const int new_square = (previous_square + dice_total) % GAME_SIZE;

			const int previous_score = get_score();
			const int new_score = previous_score + new_square + 1;
			if (new_score < WINNING_SCORE_P2)
			{
				set_state(new_score, new_square);
				return false;
			}
			return true;
		}
	private:
		uint8_t hash = 0;
	};

	auto operator<=>(PlayerStateP2 left, PlayerStateP2 right)
	{
		return left.get_hash() <=> right.get_hash();
	}

	struct GameStateP2
	{
		utils::small_vector<PlayerStateP2, NUM_PLAYERS> player_state;
		uint16_t get_hash() const
		{
			uint16_t result = 0;
			for (PlayerStateP2 ps : player_state)
			{
				result = result << 8;
				result += ps.get_hash();
			}
			return result;
		}
		// Returns true if the next player to move wins, false otherwise.
		bool try_move(int dice_roll)
		{
			AdventCheck(player_state.size() >= 2);
			const bool has_won = player_state[0].try_turn(dice_roll);
			if (has_won) return true;

			std::rotate(begin(player_state), begin(player_state) + 1, end(player_state));
			return false;
		}
	};

	auto operator<=>(const GameStateP2& left, const GameStateP2& right) noexcept
	{
		const auto ps_result = std::lexicographical_compare_three_way(
			begin(left.player_state), end(left.player_state),
			begin(right.player_state), end(right.player_state),
			[](PlayerStateP2 l, PlayerStateP2 r)
		{
			return l <=> r;
		}
		);
		return ps_result;
	}

	using MoveLengthToMultiplier = std::vector<std::pair<int, int64_t>>;

	MoveLengthToMultiplier get_move_length_multipliers()
	{
		std::map<int,int64_t> result;
		std::array<int, ROLLS_PER_TURN> roll_options;
		std::fill(begin(roll_options), end(roll_options), MIN_ROLL);

		auto next_iter = [&roll_options]()
		{
			for (int& val : roll_options)
			{
				if (val == MAX_ROLL)
				{
					val = MIN_ROLL;
				}
				else
				{
					++val;
					return true;
				}
			}
			return false;
		};

		do
		{
			const int move_length = std::accumulate(begin(roll_options), end(roll_options), 0);
			++result[move_length];
		} while (next_iter());

		return MoveLengthToMultiplier(begin(result),end(result));
	}

	using ResultMemo = utils::small_vector<int64_t, NUM_PLAYERS>;
	using ResultCache = std::vector<ResultMemo>;

	void dbg_cached_monitoring(bool cache_hit)
	{
#if DAY21DBG
		static int64_t hits = 0;
		static int64_t misses = 0;
		if (cache_hit) ++hits;
		else ++misses;

		const float hit_rate = (static_cast<float>(hits) / static_cast<float>(hits + misses));
		const int hit_pct = static_cast<int>(100.0f * hit_rate);
		log << "\rHit rate = " << hit_pct << "% (" << hits << '/' << misses << ')';
#endif
	}

	ResultMemo get_results(ResultCache& result_cache, const GameStateP2& game_state, const MoveLengthToMultiplier& move_length_cache)
	{
		AdventCheck(game_state.player_state.size() == NUM_PLAYERS);

		const uint16_t state_hash = game_state.get_hash();
		ResultMemo& result = result_cache[state_hash];
		if (!result.empty())
		{
			AdventCheck(result.size() == NUM_PLAYERS);
			dbg_cached_monitoring(true);
			return result;
		}

		result.resize(NUM_PLAYERS);

		for (auto [move_length, multiplier] : move_length_cache)
		{
			GameStateP2 new_state = game_state;
			const bool has_winner = new_state.try_move(move_length);
			if (has_winner)
			{
				result[0] += multiplier;
			}
			else
			{
				ResultMemo next_result = get_results(result_cache, new_state, move_length_cache);
				AdventCheck(next_result.size() == NUM_PLAYERS);
				std::rotate(begin(next_result), end(next_result) - 1, end(next_result));
				std::transform(begin(result), end(result), begin(next_result), begin(result),
					[multiplier](int64_t old_result, int64_t new_result)
				{
					return old_result + multiplier * new_result;
				});
			}
		}

		dbg_cached_monitoring(false);
		return result;
	}

	int64_t solve_p2(std::istream& input)
	{
		auto start_positions = get_start_positions(input);
		GameStateP2 starting_state;
		std::transform(begin(start_positions), end(start_positions), std::back_inserter(starting_state.player_state),
			[](int pos)
		{
			AdventCheck(utils::range_contains_inc(pos, 1, GAME_SIZE));
			PlayerStateP2 state;
			state.set_square(pos-1);
			return state;
		});

		log << '\n';

		const MoveLengthToMultiplier mltm = get_move_length_multipliers();
		ResultCache result_cache(std::numeric_limits<uint16_t>::max(), ResultMemo{});
		const auto results = get_results(result_cache, starting_state, mltm);
		const auto best_result = std::max_element(begin(results), end(results));
		return best_result != end(results) ? *best_result : 0;
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			"Player 1 starting position: 4\n"
			"Player 2 starting position: 8"
		};
	}
}

ResultType day_twentyone_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_twentyone_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_twentyone_p1()
{
	auto input = advent::open_puzzle_input(21);
	return solve_p1(input);
}

ResultType advent_twentyone_p2()
{
	auto input = advent::open_puzzle_input(21);
	return solve_p2(input);
}

#undef DAY21DBG
#undef ENABLE_DAY21DBG