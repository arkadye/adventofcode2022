#include "advent3.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY3DBG 1
#ifdef NDEBUG
#define DAY3DBG 0
#else
#define DAY3DBG ENABLE_DAY3DBG
#endif

#if DAY3DBG
	#include <iostream>
#endif

namespace
{
#if DAY3DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <algorithm>
#include <numeric>
#include <string_view>
#include <span>

#include <binary_find.h>
#include <small_vector.h>
#include <sorted_vector.h>

namespace
{
	constexpr char ZERO = '0';
	constexpr char ONE = '1';
	using CountType = int16_t;
	using ValueType = uint16_t;
	using BitDifferences = utils::small_vector<CountType, 12>;

	void check_char(char c)
	{
		AdventCheck(c == ZERO || c == ONE);
	}

	BitDifferences update_bit_differences(BitDifferences bit_differences, std::string_view new_bits)
	{
		if (bit_differences.empty())
		{
			bit_differences.assign(new_bits.size(), 0);
		}

		AdventCheck(bit_differences.size() == new_bits.size());

		std::transform(begin(bit_differences), end(bit_differences), begin(new_bits), begin(bit_differences),
			[](CountType original, char bit)
		{
			check_char(bit);
			switch (bit)
			{
			case ZERO:
				return --original;
			case ONE:
				return ++original;
			default:
				AdventUnreachable();
				break;
			}
			return original;
		});
		return bit_differences;
	}

	BitDifferences get_bit_differences(std::istream& input)
	{
		using It = std::istream_iterator<std::string>;
		const BitDifferences result = std::accumulate(It{ input }, It{}, BitDifferences{}, update_bit_differences);
		return result;
	}

	struct Diagnostics
	{
		ValueType gamma = 0;
		ValueType epsilon = 0;
	};

	Diagnostics get_diagnostics(const BitDifferences& bit_differences)
	{
		AdventCheckMsg(bit_differences.size() <= CHAR_BIT * sizeof(CountType), "CountType does not have enough bits. Needs ", bit_differences.size());
		const Diagnostics result = std::accumulate(begin(bit_differences), end(bit_differences), Diagnostics{},
			[](Diagnostics diag, CountType diff)
		{
			AdventCheck(diff != 0);
			diag.gamma <<= 1;
			diag.epsilon <<= 1;
			if (diff > 0)
			{
				++diag.gamma;
			}
			else if (diff < 0)
			{
				++diag.epsilon;
			}
			else
			{
				AdventUnreachable();
			}
			return diag;
		});
		return result;
	}

	Diagnostics get_diagnostics(std::istream& input)
	{
		const BitDifferences diffs = get_bit_differences(input);
		return get_diagnostics(diffs);
	}

	int solve_p1(std::istream& input)
	{
		const Diagnostics result = get_diagnostics(input);
		return result.gamma * result.epsilon;
	}
}

namespace
{
	//using SlowStorage = utils::small_vector<std::string,1>;
	//using FastStorage = utils::small_vector<std::string_view, 1>;

	enum class SearchType : bool
	{
		O2, CO2
	};

	ValueType get_value(std::string_view val)
	{
		ValueType result = std::accumulate(begin(val), end(val), ValueType{ 0 },
			[](ValueType v, char c)
		{
			check_char(c);
			const auto bit = c == ONE ? 1 : 0;
			return 2 * v + bit;
		});
		return result;
	}
	
	/*struct StorageView
	{
		FastStorage::iterator first;
		FastStorage::iterator last;
		StorageView(const StorageView&) = default;
		StorageView(FastStorage::iterator f, FastStorage::iterator l) : first(f), last(l) {}
		StorageView(FastStorage& fs) : StorageView{ begin(fs),end(fs) } {}
		std::size_t size() const
		{
			const auto result = std::distance(first, last);
			AdventCheck(result >= 0);
			return static_cast<std::size_t>(result);
		}
		bool empty() const
		{
			return first == last;
		}
	};

	SlowStorage read_input(std::istream& input)
	{
		using It = std::istream_iterator<std::string>;
		return SlowStorage{ It{input},It{} };
	}

	FastStorage get_fast_storage(const SlowStorage& ss)
	{
		return FastStorage{ begin(ss),end(ss) };
	}

	enum class SearchType : bool
	{
		O2 , CO2
	};

	char get_desired_char(StorageView vals, std::size_t idx, SearchType search)
	{
		const std::size_t num_zeroes = std::count_if(vals.first, vals.last,
			[idx](std::string_view sv)
		{
			const char c = sv[idx];
			check_char(c);
			return c == ZERO;
		});

		const std::size_t num_ones = vals.size() - num_zeroes;
		switch (search)
		{
		case SearchType::O2:
			return num_zeroes > num_ones ? ZERO : ONE;
		case SearchType::CO2:
			return num_zeroes <= num_ones ? ZERO : ONE;
		}
		AdventUnreachable();
	}

	StorageView filter_values(StorageView vals, std::size_t idx, char desired)
	{
		vals.last = std::remove_if(vals.first, vals.last,
			[idx, desired](std::string_view val)
		{
			AdventCheck(idx < val.size());
			return val[idx] != desired;
		});
		return vals;
	}

	StorageView filter_values(StorageView vals, std::size_t idx, SearchType search)
	{
		return filter_values(vals, idx, get_desired_char(vals, idx, search));
	}

	ValueType get_value(StorageView vals, std::size_t idx, SearchType search)
	{
		const std::size_t vals_remaining = vals.size();
		AdventCheck(!vals.empty());
		if (vals_remaining == 1)
		{
			return get_value(*vals.first);
		}
		vals = filter_values(vals, idx, search);
		return get_value(vals, idx + 1, search);
	}

	ValueType get_value(FastStorage& fs, SearchType search)
	{
		return get_value(StorageView{ fs }, 0, search);
	}

	ValueType get_O2(FastStorage& fs)
	{
		return get_value(fs, SearchType::O2);
	}

	ValueType get_CO2(FastStorage& fs)
	{
		return get_value(fs, SearchType::CO2);
	}

	Air get_air(FastStorage& fs)
	{
		Air result;
		result.O2 = get_O2(fs);
		result.CO2 = get_CO2(fs);
		return result;
	}

	Air get_air(std::istream& input)
	{
		const SlowStorage ss = read_input(input);
		FastStorage fs = get_fast_storage(ss);
		return get_air(fs);
	}*/

	using ValueList = utils::sorted_vector<std::string>;
	using ValueIt = ValueList::const_iterator;

	struct ValueView
	{
		ValueIt first;
		ValueIt last;
		ValueView(ValueIt b, ValueIt e) : first{ b }, last{ e }{}
		ValueView(const ValueList& vl) : ValueView{ vl.cbegin(),vl.cend() } {}
		ValueView(const ValueView&) = default;
		ValueIt begin() const { return first; }
		ValueIt end() const { return last; }
		std::size_t size() const
		{
			const auto dist = std::distance(first, last);
			AdventCheck(dist >= 0);
			return static_cast<std::size_t>(dist);
		}
		bool empty() const { return first == last; }
		bool has_one() const { return size() == 1; }
	};
	ValueIt begin(ValueView v) { return v.begin(); }
	ValueIt end(ValueView v) { return v.end(); }

	ValueList read_input(std::istream& input)
	{
		using It = std::istream_iterator<std::string>;
		return ValueList{ It{input},It{} };
	}

	void check_view(ValueView view, std::size_t idx)
	{
		if (idx == 0) return;
		if (view.empty()) return;
		ValueIt current = begin(view);
		ValueIt next = current + 1;
		while (next != end(view))
		{
			std::string_view c = *current;
			std::string_view n = *next;
			c = c.substr(0, idx - 1);
			n = n.substr(0, idx - 1);
			AdventCheck(c == n);
			current = next;
			next = current + 1;
		}
	}

	ValueIt find_break(ValueView view, std::size_t idx)
	{
		check_view(view, idx);
		if (view.empty()) return begin(view);
		if ((*begin(view))[idx] == ONE)
		{
			return begin(view);
		}

		const std::size_t mid_idx = view.size() / 2;
		const ValueIt mid_it = begin(view) + mid_idx;
		const std::string_view mid_value = *mid_it;
		AdventCheck(idx < mid_value.size());
		const char c = mid_value[idx];
		check_char(c);
		const ValueView next_view = [c, view, mid_it]()
		{
			switch (c)
			{
			case ONE:
				return ValueView{ begin(view),mid_it };
			case ZERO:
				return ValueView{ mid_it+1,end(view) };
			default:
				break;
			}
			AdventUnreachable();
			return ValueView{ view };
		}();
		return find_break(next_view, idx);
	}

	std::pair<ValueView, ValueView> split_at_idx(ValueView view, std::size_t idx)
	{
		const ValueIt middle = find_break(view, idx);
		return std::pair{ ValueView{begin(view),middle},ValueView{middle,end(view)} };
	}

	ValueView filter_view(ValueView view, std::size_t idx, SearchType search)
	{
		const auto [zeroes, ones] = split_at_idx(view, idx);
		if (zeroes.size() == ones.size())
		{
			switch (search)
			{
			case SearchType::O2:
				return ones;
			case SearchType::CO2:
				return zeroes;
			}
			AdventUnreachable();
		}

		const ValueView bigger = ones.size() > zeroes.size() ? ones : zeroes;
		const ValueView smaller = ones.size() < zeroes.size() ? ones : zeroes;
		switch (search)
		{
		case SearchType::O2:
			return bigger;
		case SearchType::CO2:
			return smaller;
		}
		AdventUnreachable();
	}

	ValueType get_value(ValueView view, std::size_t idx, SearchType search)
	{
		const std::size_t num = view.size();
		AdventCheck(!view.empty());
		if (view.has_one())
		{
			return get_value(*begin(view));
		}
		const ValueView next = filter_view(view, idx, search);
		return get_value(next, idx + 1, search);
	}

	ValueType get_value(const ValueList& values, SearchType search)
	{
		return get_value(values, 0, search);
	}

	struct Air
	{
		ValueType O2 = 0;
		ValueType CO2 = 0;
	};

	Air get_air(const ValueList& values)
	{
		Air result;
		result.O2 = get_value(values, SearchType::O2);
		result.CO2 = get_value(values, SearchType::CO2);
		return result;
	}

	Air get_air(std::istream & input)
	{
		const ValueList values = read_input(input);
		return get_air(values);
	}

	int solve_p2(std::istream& input)
	{
		const Air air = get_air(input);
		return air.O2 * air.CO2;
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			R"(00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010)"
		};
	}
}

ResultType day_three_p1_a_gamma()
{
	auto input = testcase_a();
	const BitDifferences diffs = get_bit_differences(input);
	const Diagnostics result = get_diagnostics(diffs);
	return result.gamma;
}

ResultType day_three_p1_a_epsilon()
{
	auto input = testcase_a();
	const BitDifferences diffs = get_bit_differences(input);
	const Diagnostics result = get_diagnostics(diffs);
	return result.epsilon;
}

ResultType day_three_p2_a_O2()
{
	auto input = testcase_a();
	const Air result = get_air(input);
	return result.O2;
}

ResultType day_three_p2_a_CO2()
{
	auto input = testcase_a();
	const Air result = get_air(input);
	return result.CO2;
}

ResultType advent_three_p1()
{
	auto input = advent::open_puzzle_input(3);
	return solve_p1(input);
}

ResultType advent_three_p2()
{
	auto input = advent::open_puzzle_input(3);
	return solve_p2(input);
}

#undef DAY3DBG
#undef ENABLE_DAY3DBG