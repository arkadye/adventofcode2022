#include "advent23.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY23DBG	1
#ifdef NDEBUG
#define DAY23DBG 0
#else
#define DAY23DBG ENABLE_DAY23DBG
#endif

#if DAY23DBG
	#include <iostream>
#endif

namespace
{
#if DAY23DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <array>
#include <algorithm>
#include <functional>
#include <numeric>
#include <unordered_map>
#include <map>
#include <set>
#include <vector>

#include <small_vector.h>
#include <int_range.h>
#include <parse_utils.h>

namespace
{
	enum class Occupant : char
	{
		none = 0,
		amber = 1,
		bronze = 2,
		copper = 3,
		desert = 4,
	};

	char to_char(Occupant o)
	{
		const std::unordered_map<Occupant, char> output{
			std::pair{Occupant::amber,'A'},
			std::pair{Occupant::bronze,'B'},
			std::pair{Occupant::copper,'C'},
			std::pair{Occupant::desert,'D'},
			std::pair{Occupant::none,'.'}
		};

		const auto result = output.find(o);
		AdventCheck(result != end(output));
		return result->second;
	}

	auto operator<=>(Occupant l, Occupant r)
	{
		return static_cast<int>(l) <=> static_cast<int>(r);
	}

	std::ostream& operator<<(std::ostream& out, Occupant o)
	{
		out << to_char(o);
		return out;
	}

	using Energy = int;

	Energy get_energy_per_step(Occupant occupant)
	{
		using Lookup = std::unordered_map<Occupant, Energy>;
		using Pair = Lookup::value_type;
		const Lookup lookup{
			Pair{ Occupant::amber,1 },
			Pair{ Occupant::bronze,10 },
			Pair{ Occupant::copper,100 },
			Pair{ Occupant::desert,1000 }
		};

		const auto result = lookup.find(occupant);
		AdventCheck(result != end(lookup));
		return result->second;
	}

	constexpr std::array<Occupant, 4> OCCUPANTS{ Occupant::amber,Occupant::bronze,Occupant::copper,Occupant::desert };

	using Room = utils::small_vector<Occupant, 4>;

	auto operator<=>(Room l, Room r)
	{
		return std::lexicographical_compare_three_way(begin(l), end(l), begin(r), end(r));
	}

	std::size_t get_first_occupied_idx(Room room)
	{
		for (auto i : utils::int_range{ room.size() })
		{
			if (room[i] != Occupant::none) return i;
		}
		return room.size();
	}

	bool can_enter(Room room, Occupant target)
	{
		return std::ranges::all_of(room, [target](Occupant o)
		{
			return o == target || o == Occupant::none;
		});
	}

	bool room_complete(Room room, Occupant target)
	{
		return std::ranges::all_of(room, [target](Occupant o)
		{
			return o == target;
		});
	}

	struct State
	{
		std::array<Occupant, 7> hallway = { Occupant::none };
		std::array<Room, 4> rooms;
		auto operator<=>(const State& other) const = default;
	};

	std::ostream& operator<<(std::ostream& out, const State& state)
	{
		out << "\n#############\n";
		const auto& hall = state.hallway;
		out << '#' << hall[0]
			<< hall[1] << to_char(Occupant::none)
			<< hall[2] << to_char(Occupant::none)
			<< hall[3] << to_char(Occupant::none)
			<< hall[4] << to_char(Occupant::none)
			<< hall[5] << hall[6] << "#\n";
		std::size_t inside_idx = 0;
		bool first = true;
		while (true)
		{
			out << (first ? "##" : "  ");
			bool should_continue = false;
			for (auto room : state.rooms)
			{
				if (inside_idx < room.size())
				{
					out << '#' << room[inside_idx];
					should_continue = true;
				}
				else
				{
					out << "##";
				}
			}
			out << (first ? "###" : "#") << '\n';
			if (!should_continue) break;
			++inside_idx;
			first = false;
		}
		return out;
	}

	std::size_t get_room_idx(Occupant occupant)
	{
		AdventCheck(occupant != Occupant::none);
		return static_cast<std::size_t>(occupant) - 1;
	}

	bool state_complete(const State& state)
	{
		return std::transform_reduce(begin(state.rooms), end(state.rooms), begin(OCCUPANTS), true,
			std::logical_and<bool>{}, room_complete);
	}

	std::size_t get_room_entrance_idx(std::size_t from_hallway_idx, Occupant target_room)
	{
		const std::size_t left_entrance_idx = static_cast<std::size_t>(target_room);
		const std::size_t right_entrance_idx = left_entrance_idx + 1;
		const std::size_t target_idx = from_hallway_idx <= left_entrance_idx ? left_entrance_idx : right_entrance_idx;
		return target_idx;
	}

	std::size_t state_to_hallway_idx(std::size_t idx)
	{
		AdventCheck(idx < 7);
		switch (idx)
		{
		case 0:
		case 1:
			return idx;
		case 2:
			return idx + 1;
		case 3:
			return idx + 2;
		case 4:
			return idx + 3;
		case 5:
		case 6:
			return idx + 4;
		default:
			break;
		}
		AdventUnreachable();
		return 0;
	}

	int hallway_to_hallway_steps(std::size_t idx_a, std::size_t idx_b)
	{
		const auto a = state_to_hallway_idx(idx_a);
		const auto b = state_to_hallway_idx(idx_b);
		return std::abs(static_cast<int>(a) - static_cast<int>(b));
	}

	int steps_between_hallway_and_room(std::size_t hallway_idx, Occupant target_room)
	{
		AdventCheck(target_room != Occupant::none);
		const std::size_t target_idx = get_room_entrance_idx(hallway_idx, target_room);

		// 2 steps to get past threshold and into room.
		const int result = 2 + hallway_to_hallway_steps(hallway_idx,target_idx);
		return result;
	}

	/*Energy calculate_heuristic(const State& state)
	{
		return 0;
		Energy result = 0;
		for (auto hall_idx : utils::int_range{ state.hallway.size() })
		{
			Occupant o = state.hallway[hall_idx];
			if (o == Occupant::none) continue;
			const auto steps = steps_between_hallway_and_room(hall_idx, o);
			result += get_energy_per_step(o) * steps;
		}

		for (auto room_idx : utils::int_range{ state.rooms.size() })
		{
			const Occupant target = static_cast<Occupant>(room_idx + 1);
			const Room room = state.rooms[room_idx];
			if (can_enter(room, target)) continue;
			for (auto spot_idx : utils::int_range{ room.size() })
			{
				const Occupant amphipod = room[spot_idx];
				if (amphipod == Occupant::none) continue;
				if (amphipod == target) continue;
				const auto from_entrance = get_room_entrance_idx(static_cast<std::size_t>(target), amphipod);
				const auto to_entrance = get_room_entrance_idx(static_cast<std::size_t>(amphipod), target);
				const int steps = 4 + static_cast<int>(spot_idx) + hallway_to_hallway_steps(from_entrance, to_entrance);
				result += get_energy_per_step(amphipod) * steps;
			}
		}
		return result;
	}*/

	struct Move
	{
		State new_state;
		Energy energy_used;
	};

	using MoveList = utils::small_vector<Move, 28>;

	enum class PathDirection : char
	{
		room_to_hallway, hallway_to_room
	};

	bool is_path_free(const State& state, std::size_t hallway_idx, Occupant room, PathDirection direction)
	{
		const std::size_t entrance_idx = get_room_entrance_idx(hallway_idx,room);
		const auto [search_start, search_end] = std::minmax(entrance_idx, hallway_idx);
		for (auto i : utils::int_range{ search_start,search_end + 1 })
		{
			if (direction == PathDirection::hallway_to_room && i == hallway_idx)
			{
				continue;
			}
			if (state.hallway[i] != Occupant::none)
			{
				return false;
			}
		}
		return true;
	}

	MoveList make_move_list(const State& initial)
	{
		MoveList result;

		// Looks for moves from the corridoor into the room.
		for (auto i : utils::int_range{ initial.hallway.size() })
		{
			const Occupant occupant = initial.hallway[i];
			if (occupant == Occupant::none) continue;
			const std::size_t room_idx = get_room_idx(occupant);
			if (!can_enter(initial.rooms[room_idx], occupant))
			{
				continue;
			}
			if (!is_path_free(initial, i, occupant, PathDirection::hallway_to_room))
			{
				continue;
			}

			Move move;
			State& next_state = move.new_state;
			next_state = initial;
			Room& room = next_state.rooms[room_idx];
			const std::size_t room_spot = get_first_occupied_idx(room) - 1;
			AdventCheck(room_spot < room.size());
			next_state.hallway[i] = Occupant::none;
			room[room_spot] = occupant;
			const int steps = steps_between_hallway_and_room(i, occupant) + static_cast<int>(room_spot);
			move.energy_used = get_energy_per_step(occupant) * steps;

			result.push_back(move);
		}

		// Get moves out of each room
		for (auto room_idx : utils::int_range{ initial.rooms.size() })
		{
			const Occupant room_type = static_cast<Occupant>(room_idx + 1);
			const Room room = initial.rooms[room_idx];
			if (can_enter(room, room_type)) continue;
			const std::size_t amphipod_idx = get_first_occupied_idx(room);
			if (amphipod_idx >= room.size()) continue;
			const Occupant amphipod = room[amphipod_idx];

			// Try each hallway spot.
			for (auto hallway_idx : utils::int_range{ initial.hallway.size() })
			{
				if (!is_path_free(initial, hallway_idx, room_type, PathDirection::room_to_hallway))
				{
					continue;
				}
				Move move;
				State& new_state = move.new_state;
				new_state = initial;
				new_state.hallway[hallway_idx] = amphipod;
				new_state.rooms[room_idx][amphipod_idx] = Occupant::none;
				const int steps = steps_between_hallway_and_room(hallway_idx, room_type) + static_cast<int>(amphipod_idx);
				move.energy_used = get_energy_per_step(amphipod) * steps;
				result.push_back(move);
			}
		}

		AdventCheck(result.size() <= 28);
		return result;
	}

	Energy get_shortest_path(const State& initial)
	{
		struct Node
		{
			State state;
			State previous;
			Energy energy = 0;
			auto operator<=>(const Node& other) const
			{
				return state <=> other.state;
			}
		};

		std::multimap<Energy, Node> unsearched_nodes
		{
			std::pair{0,Node{initial,State{},0}}
		};
		std::set<Node> searched_states;

		while (!unsearched_nodes.empty())
		{
			const auto node = *begin(unsearched_nodes);
			if (state_complete(node.second.state))
			{
#if DAY23DBG
				log << "\nNodes checked=" << searched_states.size() << " Energy=" << node.first << '\n';
				std::vector<std::pair<State,Energy>> states;
				Node path = node.second;
				while (true)
				{
					states.emplace_back(path.state,path.energy);
					Node prev_placeholder{ path.previous,State{} };
					const auto prev_it = searched_states.find(prev_placeholder);
					if (prev_it == end(searched_states)) break;
					path = *prev_it;
				}

				log << "Path found: ";
				for (auto it = crbegin(states); it != crend(states); ++it)
				{
					log << it->first << "Energy=" << it->second << '\n';
				}
#endif
				return node.first;
			}
			unsearched_nodes.erase(begin(unsearched_nodes));
			if (searched_states.find(Node{ node.second.state,State{} }) != end(searched_states))
			{
				continue;
			}

			searched_states.insert(node.second);
			const auto next_moves = make_move_list(node.second.state);

			for (const Move& move : next_moves)
			{
				Node next_node;
				next_node.state = move.new_state;
				next_node.previous = node.second.state;
				const int energy = move.energy_used + node.first;
				next_node.energy = energy;
				unsearched_nodes.insert(std::pair{ energy,next_node });
			}
		}
		AdventUnreachable();
		return -1;
	}

	State parse_input(std::istream& input, bool unfold)
	{
		State result;

		const auto discard_line = [&input](std::string_view expected)
		{
			std::string line;
			std::getline(input, line);
			AdventCheck(line == expected);
		};

		const auto parse_string = [&result](std::string_view line)
		{
			const auto elements = utils::get_string_elements(line, '#', 0, 1, 2, 3);
			for (auto i : utils::int_range{ elements.size() })
			{
				std::string_view element = elements[i];
				AdventCheck(element.size() == 1);
				const char abbreviation = element.front();
				const std::size_t amphipod_idx = abbreviation - 'A';
				AdventCheck(amphipod_idx < 4u);
				const Occupant amphipod = static_cast<Occupant>(amphipod_idx + 1);
				result.rooms[i].push_back(amphipod);
			}
		};

		const auto parse_line = [&input,&parse_string](std::string_view prefix, std::string_view suffix)
		{
			std::string line_s;
			std::getline(input, line_s);
			std::string_view line = line_s;
			line = utils::remove_specific_prefix(line, prefix);
			line = utils::remove_specific_suffix(line, suffix);
			parse_string(line);
		};

		// Line 1.
		discard_line("#############");

		// Line 2.
		discard_line("#...........#");

		// Line 3.
		parse_line("###", "###");

		if (unfold)
		{
			parse_string("D#C#B#A");
			parse_string("D#B#A#C");
		}

		// Line 4.
		parse_line("  #", "#");

		// Line 5.
		discard_line("  #########");

		return result;
	}

	int solve_p1(std::istream& input)
	{
		const auto state = parse_input(input, false);
		return get_shortest_path(state);
	}

	int solve_p2(std::istream& input)
	{
		const auto state = parse_input(input, true);
		return get_shortest_path(state);
	}
}

namespace
{
	std::istringstream testcase_a()
	{
		return std::istringstream{
			"#############\n"
			"#...........#\n"
			"###B#C#B#D###\n"
			"  #A#D#C#A#\n"
			"  #########"
		};
	}
}

ResultType day_twentythree_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_twentythree_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_twentythree_p1()
{
	auto input = advent::open_puzzle_input(23);
	return solve_p1(input);
}

ResultType advent_twentythree_p2()
{
	auto input = advent::open_puzzle_input(23);
	return solve_p2(input);
}

#undef DAY23DBG
#undef ENABLE_DAY23DBG