#include "advent7.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY7DBG 1
#ifdef NDEBUG
#define DAY7DBG 0
#else
#define DAY7DBG ENABLE_DAY7DBG
#endif

#if DAY7DBG
	#include <iostream>
#endif

namespace
{
#if DAY7DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <algorithm>
#include <numeric>
#include <sstream>
#include <vector>

#include <istream_line_iterator.h>
#include <to_value.h>
#include <int_range.h>
#include <min_transform.h>

namespace
{
	enum class Day
	{
		one,two
	};

	std::vector<int> get_locations(std::istream& input)
	{
		using ILI = utils::istream_line_iterator;
		std::vector<int> locations;
		std::transform(ILI{ input,',' }, ILI{}, std::back_inserter(locations), utils::to_value<int>);
		return locations;
	}

	int get_total_fuel_cost_impl(const std::vector<int>& locations, const auto& cost_function)
	{
		return std::transform_reduce(begin(locations), end(locations), 0,
			std::plus<int>{}, cost_function);
	}

	template <Day DAY>
	int get_total_fuel_cost(const std::vector<int>& locations, int target_position)
	{
		if constexpr (DAY == Day::one)
		{
			return get_total_fuel_cost_impl(locations, [target_position](int pos)
			{
				return std::abs(pos - target_position);
			});
		}
		if constexpr (DAY == Day::two)
		{
			return get_total_fuel_cost_impl(locations, [target_position](int pos)
			{
				const int total_move = std::abs(pos - target_position);
				return (total_move * (total_move + 1)) / 2;
			});
		}
	}

	template <Day DAY>
	int get_target_position(std::vector<int>& locations)
	{
		if constexpr (DAY == Day::one)
		{
			const auto mid_it = begin(locations) + locations.size() / 2;
			std::nth_element(begin(locations), mid_it, end(locations));
			return *mid_it;
		}
		if constexpr (DAY == Day::two)
		{
			const int average_position = std::accumulate(begin(locations), end(locations), 0) / locations.size();
			const int lo = get_total_fuel_cost<Day::two>(locations, average_position);
			const int hi = get_total_fuel_cost<Day::two>(locations, average_position + 1);
			return lo < hi ? average_position : average_position + 1;
		}
	}

	template <Day DAY>
	int solve_generic(std::istream& input)
	{
		std::vector<int> locations = get_locations(input);
		const int average_pos = get_target_position<DAY>(locations);
		const int total_cost = get_total_fuel_cost<DAY>(locations, average_pos);
		return total_cost;
	}

	int solve_p1(std::istream& input)
	{
		return solve_generic<Day::one>(input);
	}
}

namespace
{
	int solve_p2(std::istream& input)
	{
		return solve_generic<Day::two>(input);
	}

	std::istringstream testcase_a()
	{
		return std::istringstream{ "16,1,2,0,4,2,7,1,2,14" };
	}

	std::vector<int> get_locations_a()
	{
		auto input = testcase_a();
		return get_locations(input);
	}
}

ResultType advent7_internal::fuel_test_p1_a(int target)
{
	const auto locations = get_locations_a();
	return get_total_fuel_cost<Day::one>(locations, target);
}

ResultType day_seven_target_test_p1_a()
{
	auto locations = get_locations_a();
	return get_target_position<Day::one>(locations);
}

ResultType advent7_internal::fuel_test_p2_a(int target)
{
	const auto locations = get_locations_a();
	return get_total_fuel_cost<Day::two>(locations, target);
}

ResultType day_seven_target_test_p2_a()
{
	auto locations = get_locations_a();
	return get_target_position<Day::two>(locations);
}

ResultType day_seven_p1_a()
{
	auto input = testcase_a();
	return solve_p1(input);
}

ResultType day_seven_p2_a()
{
	auto input = testcase_a();
	return solve_p2(input);
}

ResultType advent_seven_p1()
{
	auto input = advent::open_puzzle_input(7);
	return solve_p1(input);
}

ResultType advent_seven_p2()
{
	auto input = advent::open_puzzle_input(7);
	return solve_p2(input);
}

#undef DAY7DBG
#undef ENABLE_DAY7DBG