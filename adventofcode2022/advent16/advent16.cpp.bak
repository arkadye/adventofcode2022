#include "advent16.h"
#include "../advent/advent_utils.h"

#define ENABLE_DAY16DBG 1
#ifdef NDEBUG
#define DAY16DBG 0
#else
#define DAY16DBG ENABLE_DAY16DBG
#endif

#if DAY16DBG
	#include <iostream>
#endif

namespace
{
#if DAY16DBG
	std::ostream & log = std::cout;
#else
	struct {	template <typename T> auto& operator<<(const T&) const noexcept { return *this; } } log;
#endif
}

#include <string_view>
#include <sstream>
#include <algorithm>
#include <numeric>
#include <vector>

#include <int_range.h>
#include <range_contains.h>

namespace
{
	using BinStr = std::string;
	using Data = std::string_view;

	BinStr char_to_bin(char c)
	{
		constexpr std::size_t result_len = 4;
		constexpr std::string_view allowed = "0123456789ABCDEF";
		auto val = allowed.find(c);
		AdventCheck(val < allowed.size());
		BinStr result;
		result.reserve(result_len);
		for (auto i : utils::int_range{ result_len })
		{
			const bool is_hi = val % 2;
			result.push_back(is_hi ? '1' : '0');
			val /= 2;
		}
		std::reverse(begin(result), end(result));
		return result;
	}

	BinStr str_to_bin(std::string_view input)
	{
		std::ostringstream result;
		std::ranges::transform(input, std::ostream_iterator<std::string>{result}, char_to_bin);
		return result.str();
	}

	int64_t read_number(Data data)
	{
		const int64_t result = std::accumulate(begin(data), end(data), int64_t{ 0 },
			[](int64_t current, char bit)
		{
			AdventCheck(bit == '0' || bit == '1');
			return 2 * current + (bit - '0');
		});
		return result;
	}

	struct ReadResult
	{
		Data remaining;
		int64_t result;
	};

	ReadResult read_n_bits(Data data, std::size_t n)
	{
		AdventCheck(utils::range_contains_inc(n, std::size_t{ 0 }, data.size()));
		const Data num_bits = data.substr(0, n);
		const Data remainder = data.substr(n);
		const int64_t val = read_number(num_bits);
		return ReadResult{ remainder,val };
	}

	struct ParseResult
	{
		Data remaining;
		int64_t version_sums = 0;
		int64_t result = 0;
	};

	ParseResult parse_data_packet(Data data);

	ReadResult read_literal_value(Data data, int64_t base_value)
	{
		constexpr std::size_t PACKET_BITS = 4;
		constexpr int MULTIPLIER = 1 << 4;
		const auto [value_data, should_continue] = read_n_bits(data, 1);
		const auto [remainder, value] = read_n_bits(value_data, PACKET_BITS);
		const int64_t new_base = base_value * MULTIPLIER + value;
		if (should_continue)
		{
			return read_literal_value(remainder, new_base);
		}
		else
		{
			return ReadResult{ remainder,new_base };
		}
	}

	ParseResult parse_operator(int64_t op_id, Data data)
	{
		constexpr std::size_t NUM_PACKETS_ARG_LEN = 11;
		constexpr std::size_t DATA_ARG_LEN = 15;
		const auto [len_arg_str, length_type] = read_n_bits(data, 1);
		const auto len_arg_num_bits = length_type ? NUM_PACKETS_ARG_LEN : DATA_ARG_LEN;
		auto [sub_packets, ilength] = read_n_bits(len_arg_str, len_arg_num_bits);
		const std::size_t length = static_cast<std::size_t>(ilength);

		ParseResult result;
		// Initialize result:
		switch(op_id)
		{
		case 0: // Sum
		case 3: // Max
			result.result = 0;
			break;
		case 1: // Product
			result.result = 1;
			break;
		case 2: // Min
			result.result = std::numeric_limits<decltype(result.result)>::max();
			break;
		default:
			break;
		}

		int num_parsed = 0;
		const auto combine_with_result = [op_id,&num_parsed,&result, &sub_packets]()
		{
			const ParseResult sub_result = parse_data_packet(sub_packets);
			sub_packets = sub_result.remaining;
			result.version_sums += sub_result.version_sums;
			switch (op_id)
			{
			case 0: // Sum
				result.result += sub_result.result;
				break;
			case 1: // Mul
				result.result *= sub_result.result;
				break;
			case 2: // Min
				result.result = std::min(result.result, sub_result.result);
				break;
			case 3: // Max
				result.result = std::max(result.result, sub_result.result);
				break;
			case 5: // Greater
				AdventCheck(num_parsed < 2);
				if (num_parsed == 0) result.result = sub_result.result;
				else result.result = (result.result > sub_result.result ? 1 : 0);
				break;
			case 6: // Less
				AdventCheck(num_parsed < 2);
				if (num_parsed == 0) result.result = sub_result.result;
				else result.result = (result.result < sub_result.result ? 1 : 0);
				break;
			case 7: // Equal
				AdventCheck(num_parsed < 2);
				if (num_parsed == 0) result.result = sub_result.result;
				else result.result = (result.result == sub_result.result ? 1 : 0);
				break;
			default:
				AdventUnreachable();
				break;
			}
			AdventCheck(result.result >= 0);
			++num_parsed;
		};

		if (length_type) // Number of packets
		{
			for (auto i : utils::int_range{ length })
			{
				combine_with_result();
			}
			result.remaining = sub_packets;
			return result;
		}
		else // Data len
		{
			result.remaining = sub_packets.substr(length);
			sub_packets = sub_packets.substr(0, length);
			while (!sub_packets.empty())
			{
				combine_with_result();
			}
			return result;
		}
		AdventUnreachable();
		return result;
	}

	ParseResult parse_packet_body(Data data)
	{
		constexpr std::size_t TYPE_ID_BITS = 3;
		const ReadResult type_id = read_n_bits(data, TYPE_ID_BITS);
		switch (type_id.result)
		{
		case 4: // Literal value
		{
			const ReadResult result = read_literal_value(type_id.remaining, 0);
			ParseResult ret;
			ret.remaining = result.remaining;
			ret.result = result.result;
			ret.version_sums = 0;
			return ret;
		}
		default: // Operator value
			return parse_operator(type_id.result, type_id.remaining);
		}
		AdventUnreachable();
		return ParseResult{};
	}

	ParseResult parse_data_packet(Data data)
	{
		constexpr std::size_t VERSION_BITS = 3;
		const ReadResult version = read_n_bits(data, VERSION_BITS);
		ParseResult result = parse_packet_body(version.remaining);
		result.version_sums += version.result;
		return result;
	}

	BinStr get_input(std::istream& input)
	{
		std::string result;
		std::getline(input, result);
		return result;
	}

	int64_t solve_p1(Data data)
	{
		const auto result = parse_data_packet(str_to_bin(data));
		return result.version_sums;
	}

	int64_t solve_p1(std::istream& input)
	{
		const auto data = get_input(input);
		return solve_p1(data);
	}
}

namespace
{
	int64_t solve_p2(Data data)
	{
		const auto result = parse_data_packet(str_to_bin(data));
		return result.result;
	}

	int64_t solve_p2(std::istream& input)
	{
		const auto data = get_input(input);
		return solve_p2(data);
	}
}

namespace
{
	Data testcase_a()
	{
		return "8A004A801A8002F478";
	}

	Data testcase_b()
	{
		return "620080001611562C8802118E34";
	}

	Data testcase_c()
	{
		return "C0015000016115A2E0802F182340";
	}

	Data testcase_d()
	{
		return "A0016C880162017C3686B18A3D4780";
	}

	Data testcase_e()
	{
		return "C200B40A82";
	}

	Data testcase_f()
	{
		return "04005AC33890";
	}

	Data testcase_g()
	{
		return "880086C3E88112";
	}

	Data testcase_h()
	{
		return "CE00C43D881120";
	}

	Data testcase_i()
	{
		return "D8005AC2A8F0";
	}

	Data testcase_j()
	{
		return "F600BC2D8F";
	}

	Data testcase_k()
	{
		return "9C005AC2F8F0";
	}

	Data testcase_l()
	{
		return "9C0141080250320F1802104A08";
	}
}

ResultType day_sixteen_p1_a()
{
	return solve_p1(testcase_a());
}

ResultType day_sixteen_p1_b()
{
	return solve_p1(testcase_b());
}

ResultType day_sixteen_p1_c()
{
	return solve_p1(testcase_c());
}

ResultType day_sixteen_p1_d()
{
	return solve_p1(testcase_d());
}

ResultType day_sixteen_p2_e()
{
	return solve_p2(testcase_e());
}

ResultType day_sixteen_p2_f()
{
	return solve_p2(testcase_f());
}

ResultType day_sixteen_p2_g()
{
	return solve_p2(testcase_g());
}

ResultType day_sixteen_p2_h()
{
	return solve_p2(testcase_h());
}

ResultType day_sixteen_p2_i()
{
	return solve_p2(testcase_i());
}

ResultType day_sixteen_p2_j()
{
	return solve_p2(testcase_j());
}

ResultType day_sixteen_p2_k()
{
	return solve_p2(testcase_k());
}

ResultType day_sixteen_p2_l()
{
	return solve_p2(testcase_l());
}

ResultType advent_sixteen_p1()
{
	auto input = advent::open_puzzle_input(16);
	return solve_p1(input);
}

ResultType advent_sixteen_p2()
{
	auto input = advent::open_puzzle_input(16);
	return solve_p2(input);
}

#undef DAY16DBG
#undef ENABLE_DAY16DBG